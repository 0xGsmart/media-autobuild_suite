From f9a144f999fd46cb8f9e583b624a08639b5c8e3d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Martin=20Storsj=C3=B6?= <martin@martin.st>
Date: Wed, 11 Nov 2015 22:47:52 +0200
Subject: [PATCH] xtea: Clarify that the current API works in big endian mode

xtea: Add functions for little endian mode

rtmpcrypt: Do the xtea decryption in little endian mode

The XTEA algorithm operates on 32 bit numbers, not on byte sequences.
The XTEA implementation in libavutil is written assuming big endian
numbers, while the rtmpe signature encryption assumes little endian.

This fixes rtmpe communication with rtmpe servers that use signature
type 8 (XTEA), e.g. crunchyroll.

rtmpcrypt: Provide the xtea keys in little endian format for consistency
---
 libavformat/rtmpcrypt.c | 68 +++++++++++++++++------------------
 libavutil/version.h     |  2 +-
 libavutil/xtea.c        | 94 ++++++++++++++++++++++++++++++++++++++++++-------
 libavutil/xtea.h        | 29 +++++++++++++--
 4 files changed, 143 insertions(+), 50 deletions(-)

diff --git a/libavformat/rtmpcrypt.c b/libavformat/rtmpcrypt.c
index 2065ec6..a0c914f 100644
--- a/libavformat/rtmpcrypt.c
+++ b/libavformat/rtmpcrypt.c
@@ -50,38 +50,38 @@ typedef struct RTMPEContext {
 } RTMPEContext;
 
 static const uint8_t rtmpe8_keys[16][16] = {
-    { 0xbf, 0xf0, 0x34, 0xb2, 0x11, 0xd9, 0x08, 0x1f,
-      0xcc, 0xdf, 0xb7, 0x95, 0x74, 0x8d, 0xe7, 0x32 },
-    { 0x08, 0x6a, 0x5e, 0xb6, 0x17, 0x43, 0x09, 0x0e,
-      0x6e, 0xf0, 0x5a, 0xb8, 0xfe, 0x5a, 0x39, 0xe2 },
-    { 0x7b, 0x10, 0x95, 0x6f, 0x76, 0xce, 0x05, 0x21,
-      0x23, 0x88, 0xa7, 0x3a, 0x44, 0x01, 0x49, 0xa1 },
-    { 0xa9, 0x43, 0xf3, 0x17, 0xeb, 0xf1, 0x1b, 0xb2,
-      0xa6, 0x91, 0xa5, 0xee, 0x17, 0xf3, 0x63, 0x39 },
-    { 0x7a, 0x30, 0xe0, 0x0a, 0xb5, 0x29, 0xe2, 0x2c,
-      0xa0, 0x87, 0xae, 0xa5, 0xc0, 0xcb, 0x79, 0xac },
-    { 0xbd, 0xce, 0x0c, 0x23, 0x2f, 0xeb, 0xde, 0xff,
-      0x1c, 0xfa, 0xae, 0x16, 0x11, 0x23, 0x23, 0x9d },
-    { 0x55, 0xdd, 0x3f, 0x7b, 0x77, 0xe7, 0xe6, 0x2e,
-      0x9b, 0xb8, 0xc4, 0x99, 0xc9, 0x48, 0x1e, 0xe4 },
-    { 0x40, 0x7b, 0xb6, 0xb4, 0x71, 0xe8, 0x91, 0x36,
-      0xa7, 0xae, 0xbf, 0x55, 0xca, 0x33, 0xb8, 0x39 },
-    { 0xfc, 0xf6, 0xbd, 0xc3, 0xb6, 0x3c, 0x36, 0x97,
-      0x7c, 0xe4, 0xf8, 0x25, 0x04, 0xd9, 0x59, 0xb2 },
-    { 0x28, 0xe0, 0x91, 0xfd, 0x41, 0x95, 0x4c, 0x4c,
-      0x7f, 0xb7, 0xdb, 0x00, 0xe3, 0xa0, 0x66, 0xf8 },
-    { 0x57, 0x84, 0x5b, 0x76, 0x4f, 0x25, 0x1b, 0x03,
-      0x46, 0xd4, 0x5b, 0xcd, 0xa2, 0xc3, 0x0d, 0x29 },
-    { 0x0a, 0xcc, 0xee, 0xf8, 0xda, 0x55, 0xb5, 0x46,
-      0x03, 0x47, 0x34, 0x52, 0x58, 0x63, 0x71, 0x3b },
-    { 0xb8, 0x20, 0x75, 0xdc, 0xa7, 0x5f, 0x1f, 0xee,
-      0xd8, 0x42, 0x68, 0xe8, 0xa7, 0x2a, 0x44, 0xcc },
-    { 0x07, 0xcf, 0x6e, 0x9e, 0xa1, 0x6d, 0x7b, 0x25,
-      0x9f, 0xa7, 0xae, 0x6c, 0xd9, 0x2f, 0x56, 0x29 },
-    { 0xfe, 0xb1, 0xea, 0xe4, 0x8c, 0x8c, 0x3c, 0xe1,
-      0x4e, 0x00, 0x64, 0xa7, 0x6a, 0x38, 0x7c, 0x2a },
-    { 0x89, 0x3a, 0x94, 0x27, 0xcc, 0x30, 0x13, 0xa2,
-      0xf1, 0x06, 0x38, 0x5b, 0xa8, 0x29, 0xf9, 0x27 }
+    { 0xb2, 0x34, 0xf0, 0xbf, 0x1f, 0x08, 0xd9, 0x11,
+      0x95, 0xb7, 0xdf, 0xcc, 0x32, 0xe7, 0x8d, 0x74 },
+    { 0xb6, 0x5e, 0x6a, 0x08, 0x0e, 0x09, 0x43, 0x17,
+      0xb8, 0x5a, 0xf0, 0x6e, 0xe2, 0x39, 0x5a, 0xfe },
+    { 0x6f, 0x95, 0x10, 0x7b, 0x21, 0x05, 0xce, 0x76,
+      0x3a, 0xa7, 0x88, 0x23, 0xa1, 0x49, 0x01, 0x44 },
+    { 0x17, 0xf3, 0x43, 0xa9, 0xb2, 0x1b, 0xf1, 0xeb,
+      0xee, 0xa5, 0x91, 0xa6, 0x39, 0x63, 0xf3, 0x17 },
+    { 0x0a, 0xe0, 0x30, 0x7a, 0x2c, 0xe2, 0x29, 0xb5,
+      0xa5, 0xae, 0x87, 0xa0, 0xac, 0x79, 0xcb, 0xc0 },
+    { 0x23, 0x0c, 0xce, 0xbd, 0xff, 0xde, 0xeb, 0x2f,
+      0x16, 0xae, 0xfa, 0x1c, 0x9d, 0x23, 0x23, 0x11 },
+    { 0x7b, 0x3f, 0xdd, 0x55, 0x2e, 0xe6, 0xe7, 0x77,
+      0x99, 0xc4, 0xb8, 0x9b, 0xe4, 0x1e, 0x48, 0xc9 },
+    { 0xb4, 0xb6, 0x7b, 0x40, 0x36, 0x91, 0xe8, 0x71,
+      0x55, 0xbf, 0xae, 0xa7, 0x39, 0xb8, 0x33, 0xca },
+    { 0xc3, 0xbd, 0xf6, 0xfc, 0x97, 0x36, 0x3c, 0xb6,
+      0x25, 0xf8, 0xe4, 0x7c, 0xb2, 0x59, 0xd9, 0x04 },
+    { 0xfd, 0x91, 0xe0, 0x28, 0x4c, 0x4c, 0x95, 0x41,
+      0x00, 0xdb, 0xb7, 0x7f, 0xf8, 0x66, 0xa0, 0xe3 },
+    { 0x76, 0x5b, 0x84, 0x57, 0x03, 0x1b, 0x25, 0x4f,
+      0xcd, 0x5b, 0xd4, 0x46, 0x29, 0x0d, 0xc3, 0xa2 },
+    { 0xf8, 0xee, 0xcc, 0x0a, 0x46, 0xb5, 0x55, 0xda,
+      0x52, 0x34, 0x47, 0x03, 0x3b, 0x71, 0x63, 0x58 },
+    { 0xdc, 0x75, 0x20, 0xb8, 0xee, 0x1f, 0x5f, 0xa7,
+      0xe8, 0x68, 0x42, 0xd8, 0xcc, 0x44, 0x2a, 0xa7 },
+    { 0x9e, 0x6e, 0xcf, 0x07, 0x25, 0x7b, 0x6d, 0xa1,
+      0x6c, 0xae, 0xa7, 0x9f, 0x29, 0x56, 0x2f, 0xd9 },
+    { 0xe4, 0xea, 0xb1, 0xfe, 0xe1, 0x3c, 0x8c, 0x8c,
+      0xa7, 0x64, 0x00, 0x4e, 0x2a, 0x7c, 0x38, 0x6a },
+    { 0x27, 0x94, 0x3a, 0x89, 0xa2, 0x13, 0x30, 0xcc,
+      0x5b, 0x38, 0x06, 0xf1, 0x27, 0xf9, 0x29, 0xa8 }
 };
 
 static const uint8_t rtmpe9_keys[16][24] = {
@@ -185,8 +185,8 @@ static void rtmpe8_sig(const uint8_t *in, uint8_t *out, int key_id)
 {
     struct AVXTEA ctx;
 
-    av_xtea_init(&ctx, rtmpe8_keys[key_id]);
-    av_xtea_crypt(&ctx, out, in, 1, NULL, 0);
+    av_xtea_le_init(&ctx, rtmpe8_keys[key_id]);
+    av_xtea_le_crypt(&ctx, out, in, 1, NULL, 0);
 }
 
 static void rtmpe9_sig(const uint8_t *in, uint8_t *out, int key_id)
diff --git a/libavutil/version.h b/libavutil/version.h
index 909f9a6..bcad658 100644
--- a/libavutil/version.h
+++ b/libavutil/version.h
@@ -56,7 +56,7 @@
  */
 
 #define LIBAVUTIL_VERSION_MAJOR  55
-#define LIBAVUTIL_VERSION_MINOR   5
+#define LIBAVUTIL_VERSION_MINOR   6
 #define LIBAVUTIL_VERSION_MICRO 100
 
 #define LIBAVUTIL_VERSION_INT   AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, \
diff --git a/libavutil/xtea.c b/libavutil/xtea.c
index 0d58cba..2139aa5 100644
--- a/libavutil/xtea.c
+++ b/libavutil/xtea.c
@@ -47,6 +47,14 @@ void av_xtea_init(AVXTEA *ctx, const uint8_t key[16])
         ctx->key[i] = AV_RB32(key + (i << 2));
 }
 
+void av_xtea_le_init(AVXTEA *ctx, const uint8_t key[16])
+{
+    int i;
+
+    for (i = 0; i < 4; i++)
+        ctx->key[i] = AV_RL32(key + (i << 2));
+}
+
 static void xtea_crypt_ecb(AVXTEA *ctx, uint8_t *dst, const uint8_t *src,
                            int decrypt, uint8_t *iv)
 {
@@ -167,14 +175,51 @@ static void xtea_crypt_ecb(AVXTEA *ctx, uint8_t *dst, const uint8_t *src,
     AV_WB32(dst + 4, v1);
 }
 
-void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,
-                   uint8_t *iv, int decrypt)
+static void xtea_le_crypt_ecb(AVXTEA *ctx, uint8_t *dst, const uint8_t *src,
+                              int decrypt, uint8_t *iv)
+{
+    uint32_t v0, v1;
+    int i;
+
+    v0 = AV_RL32(src);
+    v1 = AV_RL32(src + 4);
+
+    if (decrypt) {
+        uint32_t delta = 0x9E3779B9, sum = delta * 32;
+
+        for (i = 0; i < 32; i++) {
+            v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + ctx->key[(sum >> 11) & 3]);
+            sum -= delta;
+            v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + ctx->key[sum & 3]);
+        }
+        if (iv) {
+            v0 ^= AV_RL32(iv);
+            v1 ^= AV_RL32(iv + 4);
+            memcpy(iv, src, 8);
+        }
+    } else {
+        uint32_t sum = 0, delta = 0x9E3779B9;
+
+        for (i = 0; i < 32; i++) {
+            v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + ctx->key[sum & 3]);
+            sum += delta;
+            v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + ctx->key[(sum >> 11) & 3]);
+        }
+    }
+
+    AV_WL32(dst, v0);
+    AV_WL32(dst + 4, v1);
+}
+
+static void xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,
+                       uint8_t *iv, int decrypt,
+                       void (*crypt)(AVXTEA *, uint8_t *, const uint8_t *, int, uint8_t *))
 {
     int i;
 
     if (decrypt) {
         while (count--) {
-            xtea_crypt_ecb(ctx, dst, src, decrypt, iv);
+            crypt(ctx, dst, src, decrypt, iv);
 
             src   += 8;
             dst   += 8;
@@ -184,10 +229,10 @@ void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,
             if (iv) {
                 for (i = 0; i < 8; i++)
                     dst[i] = src[i] ^ iv[i];
-                xtea_crypt_ecb(ctx, dst, dst, decrypt, NULL);
+                crypt(ctx, dst, dst, decrypt, NULL);
                 memcpy(iv, dst, 8);
             } else {
-                xtea_crypt_ecb(ctx, dst, src, decrypt, NULL);
+                crypt(ctx, dst, src, decrypt, NULL);
             }
             src   += 8;
             dst   += 8;
@@ -195,6 +240,18 @@ void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,
     }
 }
 
+void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,
+                   uint8_t *iv, int decrypt)
+{
+    xtea_crypt(ctx, dst, src, count, iv, decrypt, xtea_crypt_ecb);
+}
+
+void av_xtea_le_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,
+                      uint8_t *iv, int decrypt)
+{
+    xtea_crypt(ctx, dst, src, count, iv, decrypt, xtea_le_crypt_ecb);
+}
+
 #ifdef TEST
 #include <stdio.h>
 
@@ -235,9 +292,10 @@ static const uint8_t xtea_test_ct[XTEA_NUM_TESTS][8] = {
 
 static void test_xtea(AVXTEA *ctx, uint8_t *dst, const uint8_t *src,
                       const uint8_t *ref, int len, uint8_t *iv, int dir,
-                      const char *test)
+                      const char *test,
+                      void (*crypt)(AVXTEA *, uint8_t *, const uint8_t *, int, uint8_t *, int))
 {
-    av_xtea_crypt(ctx, dst, src, len, iv, dir);
+    crypt(ctx, dst, src, len, iv, dir);
     if (memcmp(dst, ref, 8*len)) {
         int i;
         printf("%s failed\ngot      ", test);
@@ -254,8 +312,8 @@ static void test_xtea(AVXTEA *ctx, uint8_t *dst, const uint8_t *src,
 int main(void)
 {
     AVXTEA ctx;
-    uint8_t buf[8], iv[8];
-    int i;
+    uint8_t buf[16], iv[8];
+    int i, j;
     static const uint8_t src[32] = "HelloWorldHelloWorldHelloWorld";
     uint8_t ct[32];
     uint8_t pl[32];
@@ -263,8 +321,18 @@ int main(void)
     for (i = 0; i < XTEA_NUM_TESTS; i++) {
         av_xtea_init(&ctx, xtea_test_key[i]);
 
-        test_xtea(&ctx, buf, xtea_test_pt[i], xtea_test_ct[i], 1, NULL, 0, "encryption");
-        test_xtea(&ctx, buf, xtea_test_ct[i], xtea_test_pt[i], 1, NULL, 1, "decryption");
+        test_xtea(&ctx, buf, xtea_test_pt[i], xtea_test_ct[i], 1, NULL, 0, "encryption", av_xtea_crypt);
+        test_xtea(&ctx, buf, xtea_test_ct[i], xtea_test_pt[i], 1, NULL, 1, "decryption", av_xtea_crypt);
+
+        for (j = 0; j < 4; j++)
+            AV_WL32(&buf[4*j], AV_RB32(&xtea_test_key[i][4*j]));
+        av_xtea_le_init(&ctx, buf);
+        for (j = 0; j < 2; j++) {
+            AV_WL32(&ct[4*j], AV_RB32(&xtea_test_ct[i][4*j]));
+            AV_WL32(&pl[4*j], AV_RB32(&xtea_test_pt[i][4*j]));
+        }
+        test_xtea(&ctx, buf, pl, ct, 1, NULL, 0, "encryption", av_xtea_le_crypt);
+        test_xtea(&ctx, buf, ct, pl, 1, NULL, 1, "decryption", av_xtea_le_crypt);
 
         /* encrypt */
         memcpy(iv, "HALLO123", 8);
@@ -272,10 +340,10 @@ int main(void)
 
         /* decrypt into pl */
         memcpy(iv, "HALLO123", 8);
-        test_xtea(&ctx, pl, ct, src, 4, iv, 1, "CBC decryption");
+        test_xtea(&ctx, pl, ct, src, 4, iv, 1, "CBC decryption", av_xtea_crypt);
 
         memcpy(iv, "HALLO123", 8);
-        test_xtea(&ctx, ct, ct, src, 4, iv, 1, "CBC inplace decryption");
+        test_xtea(&ctx, ct, ct, src, 4, iv, 1, "CBC inplace decryption", av_xtea_crypt);
     }
 
     printf("Test encryption/decryption success.\n");
diff --git a/libavutil/xtea.h b/libavutil/xtea.h
index bcf786c..735427c 100644
--- a/libavutil/xtea.h
+++ b/libavutil/xtea.h
@@ -45,12 +45,23 @@ AVXTEA *av_xtea_alloc(void);
  * Initialize an AVXTEA context.
  *
  * @param ctx an AVXTEA context
- * @param key a key of 16 bytes used for encryption/decryption
+ * @param key a key of 16 bytes used for encryption/decryption,
+ *            interpreted as big endian 32 bit numbers
  */
 void av_xtea_init(struct AVXTEA *ctx, const uint8_t key[16]);
 
 /**
- * Encrypt or decrypt a buffer using a previously initialized context.
+ * Initialize an AVXTEA context.
+ *
+ * @param ctx an AVXTEA context
+ * @param key a key of 16 bytes used for encryption/decryption,
+ *            interpreted as little endian 32 bit numbers
+ */
+void av_xtea_le_init(struct AVXTEA *ctx, const uint8_t key[16]);
+
+/**
+ * Encrypt or decrypt a buffer using a previously initialized context,
+ * in big endian format.
  *
  * @param ctx an AVXTEA context
  * @param dst destination array, can be equal to src
@@ -63,6 +74,20 @@ void av_xtea_crypt(struct AVXTEA *ctx, uint8_t *dst, const uint8_t *src,
                    int count, uint8_t *iv, int decrypt);
 
 /**
+ * Encrypt or decrypt a buffer using a previously initialized context,
+ * in little endian format.
+ *
+ * @param ctx an AVXTEA context
+ * @param dst destination array, can be equal to src
+ * @param src source array, can be equal to dst
+ * @param count number of 8 byte blocks
+ * @param iv initialization vector for CBC mode, if NULL then ECB will be used
+ * @param decrypt 0 for encryption, 1 for decryption
+ */
+void av_xtea_le_crypt(struct AVXTEA *ctx, uint8_t *dst, const uint8_t *src,
+                      int count, uint8_t *iv, int decrypt);
+
+/**
  * @}
  */
 
-- 
2.6.2

