From 0579214ce3c64f1188b710a31082c5f9bc9b4b25 Mon Sep 17 00:00:00 2001
From: Timo Rothenpieler <timo@rothenpieler.org>
Date: Mon, 10 Oct 2016 12:47:15 +0200
Subject: [PATCH 1/8] compat/cuda: add dynamic loader

---
 compat/cuda/dynlink_cuda.h     |  97 +++++
 compat/cuda/dynlink_cuviddec.h | 808 +++++++++++++++++++++++++++++++++++++++++
 compat/cuda/dynlink_loader.h   | 263 ++++++++++++++
 compat/cuda/dynlink_nvcuvid.h  | 316 ++++++++++++++++
 4 files changed, 1484 insertions(+)
 create mode 100644 compat/cuda/dynlink_cuda.h
 create mode 100644 compat/cuda/dynlink_cuviddec.h
 create mode 100644 compat/cuda/dynlink_loader.h
 create mode 100644 compat/cuda/dynlink_nvcuvid.h

diff --git a/compat/cuda/dynlink_cuda.h b/compat/cuda/dynlink_cuda.h
new file mode 100644
index 0000000..418bbd0
--- /dev/null
+++ b/compat/cuda/dynlink_cuda.h
@@ -0,0 +1,97 @@
+/*
+ * This copyright notice applies to this header file only:
+ *
+ * Copyright (c) 2016
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the software, and to permit persons to whom the
+ * software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#if !defined(AV_COMPAT_DYNLINK_CUDA_H) && !defined(CUDA_VERSION)
+#define AV_COMPAT_DYNLINK_CUDA_H
+
+#include <stddef.h>
+
+#define CUDA_VERSION 7050
+
+#if defined(_WIN32) || defined(__CYGWIN__)
+#define CUDAAPI __stdcall
+#else
+#define CUDAAPI
+#endif
+
+#define CU_CTX_SCHED_BLOCKING_SYNC 4
+
+typedef int CUdevice;
+typedef void* CUarray;
+typedef void* CUcontext;
+#if defined(__x86_64) || defined(AMD64) || defined(_M_AMD64)
+typedef unsigned long long CUdeviceptr;
+#else
+typedef unsigned int CUdeviceptr;
+#endif
+
+typedef enum cudaError_enum {
+    CUDA_SUCCESS = 0
+} CUresult;
+
+typedef enum CUmemorytype_enum {
+    CU_MEMORYTYPE_HOST = 1,
+    CU_MEMORYTYPE_DEVICE = 2
+} CUmemorytype;
+
+typedef struct CUDA_MEMCPY2D_st {
+    size_t srcXInBytes;
+    size_t srcY;
+    CUmemorytype srcMemoryType;
+    const void *srcHost;
+    CUdeviceptr srcDevice;
+    CUarray srcArray;
+    size_t srcPitch;
+
+    size_t dstXInBytes;
+    size_t dstY;
+    CUmemorytype dstMemoryType;
+    void *dstHost;
+    CUdeviceptr dstDevice;
+    CUarray dstArray;
+    size_t dstPitch;
+
+    size_t WidthInBytes;
+    size_t Height;
+} CUDA_MEMCPY2D;
+
+typedef CUresult CUDAAPI tcuInit(unsigned int Flags);
+typedef CUresult CUDAAPI tcuDeviceGetCount(int *count);
+typedef CUresult CUDAAPI tcuDeviceGet(CUdevice *device, int ordinal);
+typedef CUresult CUDAAPI tcuDeviceGetName(char *name, int len, CUdevice dev);
+typedef CUresult CUDAAPI tcuDeviceComputeCapability(int *major, int *minor, CUdevice dev);
+typedef CUresult CUDAAPI tcuCtxCreate_v2(CUcontext *pctx, unsigned int flags, CUdevice dev);
+typedef CUresult CUDAAPI tcuCtxPushCurrent_v2(CUcontext *pctx);
+typedef CUresult CUDAAPI tcuCtxPopCurrent_v2(CUcontext *pctx);
+typedef CUresult CUDAAPI tcuCtxDestroy_v2(CUcontext ctx);
+typedef CUresult CUDAAPI tcuMemAlloc_v2(CUdeviceptr *dptr, size_t bytesize);
+typedef CUresult CUDAAPI tcuMemFree_v2(CUdeviceptr dptr);
+typedef CUresult CUDAAPI tcuMemcpy2D_v2(const CUDA_MEMCPY2D *pcopy);
+typedef CUresult CUDAAPI tcuGetErrorName(CUresult error, const char** pstr);
+typedef CUresult CUDAAPI tcuGetErrorString(CUresult error, const char** pstr);
+
+#endif
diff --git a/compat/cuda/dynlink_cuviddec.h b/compat/cuda/dynlink_cuviddec.h
new file mode 100644
index 0000000..17207bc
--- /dev/null
+++ b/compat/cuda/dynlink_cuviddec.h
@@ -0,0 +1,808 @@
+/*
+ * This copyright notice applies to this header file only:
+ *
+ * Copyright (c) 2010-2016 NVIDIA Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the software, and to permit persons to whom the
+ * software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file cuviddec.h
+ * NvCuvid API provides Video Decoding interface to NVIDIA GPU devices.
+ * \date 2015-2016
+ * This file contains constants, structure definitions and function prototypes used for decoding.
+ */
+
+#if !defined(__CUDA_VIDEO_H__)
+#define __CUDA_VIDEO_H__
+
+#if defined(__x86_64) || defined(AMD64) || defined(_M_AMD64)
+#if (CUDA_VERSION >= 3020) && (!defined(CUDA_FORCE_API_VERSION) || (CUDA_FORCE_API_VERSION >= 3020))
+#define __CUVID_DEVPTR64
+#endif
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif /* __cplusplus */
+
+typedef void *CUvideodecoder;
+typedef struct _CUcontextlock_st *CUvideoctxlock;
+
+/**
+ * \addtogroup VIDEO_DECODER Video Decoder
+ * @{
+ */
+
+/*!
+ * \enum cudaVideoCodec
+ * Video Codec Enums
+ */
+typedef enum cudaVideoCodec_enum {
+    cudaVideoCodec_MPEG1=0,                 /**<  MPEG1   */
+    cudaVideoCodec_MPEG2,                   /**<  MPEG2  */
+    cudaVideoCodec_MPEG4,                   /**<  MPEG4   */
+    cudaVideoCodec_VC1,                     /**<  VC1   */
+    cudaVideoCodec_H264,                    /**<  H264   */
+    cudaVideoCodec_JPEG,                    /**<  JPEG   */
+    cudaVideoCodec_H264_SVC,                /**<  H264-SVC   */
+    cudaVideoCodec_H264_MVC,                /**<  H264-MVC   */
+    cudaVideoCodec_HEVC,                    /**<  HEVC   */
+    cudaVideoCodec_VP8,                     /**<  VP8   */
+    cudaVideoCodec_VP9,                     /**<  VP9   */
+    cudaVideoCodec_NumCodecs,               /**<  Max COdecs   */
+    // Uncompressed YUV
+    cudaVideoCodec_YUV420 = (('I'<<24)|('Y'<<16)|('U'<<8)|('V')),   /**< Y,U,V (4:2:0)  */
+    cudaVideoCodec_YV12   = (('Y'<<24)|('V'<<16)|('1'<<8)|('2')),   /**< Y,V,U (4:2:0)  */
+    cudaVideoCodec_NV12   = (('N'<<24)|('V'<<16)|('1'<<8)|('2')),   /**< Y,UV  (4:2:0)  */
+    cudaVideoCodec_YUYV   = (('Y'<<24)|('U'<<16)|('Y'<<8)|('V')),   /**< YUYV/YUY2 (4:2:2)  */
+    cudaVideoCodec_UYVY   = (('U'<<24)|('Y'<<16)|('V'<<8)|('Y'))    /**< UYVY (4:2:2)  */
+} cudaVideoCodec;
+
+/*!
+ * \enum cudaVideoSurfaceFormat
+ * Video Surface Formats Enums
+ */
+typedef enum cudaVideoSurfaceFormat_enum {
+    cudaVideoSurfaceFormat_NV12=0       /**< NV12 (currently the only supported output format)  */
+} cudaVideoSurfaceFormat;
+
+/*!
+ * \enum cudaVideoDeinterlaceMode
+ * Deinterlacing Modes Enums
+ */
+typedef enum cudaVideoDeinterlaceMode_enum {
+    cudaVideoDeinterlaceMode_Weave=0,   /**< Weave both fields (no deinterlacing) */
+    cudaVideoDeinterlaceMode_Bob,       /**< Drop one field  */
+    cudaVideoDeinterlaceMode_Adaptive   /**< Adaptive deinterlacing  */
+} cudaVideoDeinterlaceMode;
+
+/*!
+ * \enum cudaVideoChromaFormat
+ * Chroma Formats Enums
+ */
+typedef enum cudaVideoChromaFormat_enum {
+    cudaVideoChromaFormat_Monochrome=0,  /**< MonoChrome */
+    cudaVideoChromaFormat_420,           /**< 4:2:0 */
+    cudaVideoChromaFormat_422,           /**< 4:2:2 */
+    cudaVideoChromaFormat_444            /**< 4:4:4 */
+} cudaVideoChromaFormat;
+
+/*!
+ * \enum cudaVideoCreateFlags
+ * Decoder Flags Enums
+ */
+typedef enum cudaVideoCreateFlags_enum {
+    cudaVideoCreate_Default = 0x00,     /**< Default operation mode: use dedicated video engines */
+    cudaVideoCreate_PreferCUDA = 0x01,  /**< Use a CUDA-based decoder if faster than dedicated engines (requires a valid vidLock object for multi-threading) */
+    cudaVideoCreate_PreferDXVA = 0x02,  /**< Go through DXVA internally if possible (requires D3D9 interop) */
+    cudaVideoCreate_PreferCUVID = 0x04  /**< Use dedicated video engines directly */
+} cudaVideoCreateFlags;
+
+/*!
+ * \struct CUVIDDECODECREATEINFO
+ * Struct used in create decoder
+ */
+typedef struct _CUVIDDECODECREATEINFO
+{
+    unsigned long ulWidth;              /**< Coded Sequence Width */
+    unsigned long ulHeight;             /**< Coded Sequence Height */
+    unsigned long ulNumDecodeSurfaces;  /**< Maximum number of internal decode surfaces */
+    cudaVideoCodec CodecType;           /**< cudaVideoCodec_XXX */
+    cudaVideoChromaFormat ChromaFormat; /**< cudaVideoChromaFormat_XXX (only 4:2:0 is currently supported) */
+    unsigned long ulCreationFlags;      /**< Decoder creation flags (cudaVideoCreateFlags_XXX) */
+    unsigned long bitDepthMinus8;
+    unsigned long Reserved1[4];         /**< Reserved for future use - set to zero */
+    /**
+    * area of the frame that should be displayed
+    */
+    struct {
+        short left;
+        short top;
+        short right;
+        short bottom;
+    } display_area;
+
+    cudaVideoSurfaceFormat OutputFormat;       /**< cudaVideoSurfaceFormat_XXX */
+    cudaVideoDeinterlaceMode DeinterlaceMode;  /**< cudaVideoDeinterlaceMode_XXX */
+    unsigned long ulTargetWidth;               /**< Post-processed Output Width (Should be aligned to 2) */
+    unsigned long ulTargetHeight;              /**< Post-processed Output Height (Should be aligbed to 2) */
+    unsigned long ulNumOutputSurfaces;         /**< Maximum number of output surfaces simultaneously mapped */
+    CUvideoctxlock vidLock;                    /**< If non-NULL, context lock used for synchronizing ownership of the cuda context */
+    /**
+    * target rectangle in the output frame (for aspect ratio conversion)
+    * if a null rectangle is specified, {0,0,ulTargetWidth,ulTargetHeight} will be used
+    */
+    struct {
+        short left;
+        short top;
+        short right;
+        short bottom;
+    } target_rect;
+    unsigned long Reserved2[5];                /**< Reserved for future use - set to zero */
+} CUVIDDECODECREATEINFO;
+
+/*!
+ * \struct CUVIDH264DPBENTRY
+ * H.264 DPB Entry
+ */
+typedef struct _CUVIDH264DPBENTRY
+{
+    int PicIdx;                 /**< picture index of reference frame */
+    int FrameIdx;               /**< frame_num(short-term) or LongTermFrameIdx(long-term) */
+    int is_long_term;           /**< 0=short term reference, 1=long term reference */
+    int not_existing;           /**< non-existing reference frame (corresponding PicIdx should be set to -1) */
+    int used_for_reference;     /**< 0=unused, 1=top_field, 2=bottom_field, 3=both_fields */
+    int FieldOrderCnt[2];       /**< field order count of top and bottom fields */
+} CUVIDH264DPBENTRY;
+
+/*!
+ * \struct CUVIDH264MVCEXT
+ * H.264 MVC Picture Parameters Ext
+ */
+typedef struct _CUVIDH264MVCEXT
+{
+    int num_views_minus1;
+    int view_id;
+    unsigned char inter_view_flag;
+    unsigned char num_inter_view_refs_l0;
+    unsigned char num_inter_view_refs_l1;
+    unsigned char MVCReserved8Bits;
+    int InterViewRefsL0[16];
+    int InterViewRefsL1[16];
+} CUVIDH264MVCEXT;
+
+/*!
+ * \struct CUVIDH264SVCEXT
+ * H.264 SVC Picture Parameters Ext
+ */
+typedef struct _CUVIDH264SVCEXT
+{
+    unsigned char profile_idc;
+    unsigned char level_idc;
+    unsigned char DQId;
+    unsigned char DQIdMax;
+    unsigned char disable_inter_layer_deblocking_filter_idc;
+    unsigned char ref_layer_chroma_phase_y_plus1;
+    signed char   inter_layer_slice_alpha_c0_offset_div2;
+    signed char   inter_layer_slice_beta_offset_div2;
+
+    unsigned short DPBEntryValidFlag;
+    unsigned char inter_layer_deblocking_filter_control_present_flag;
+    unsigned char extended_spatial_scalability_idc;
+    unsigned char adaptive_tcoeff_level_prediction_flag;
+    unsigned char slice_header_restriction_flag;
+    unsigned char chroma_phase_x_plus1_flag;
+    unsigned char chroma_phase_y_plus1;
+
+    unsigned char tcoeff_level_prediction_flag;
+    unsigned char constrained_intra_resampling_flag;
+    unsigned char ref_layer_chroma_phase_x_plus1_flag;
+    unsigned char store_ref_base_pic_flag;
+    unsigned char Reserved8BitsA;
+    unsigned char Reserved8BitsB;
+    // For the 4 scaled_ref_layer_XX fields below,
+    // if (extended_spatial_scalability_idc == 1), SPS field, G.7.3.2.1.4, add prefix "seq_"
+    // if (extended_spatial_scalability_idc == 2), SLH field, G.7.3.3.4,
+    short scaled_ref_layer_left_offset;
+    short scaled_ref_layer_top_offset;
+    short scaled_ref_layer_right_offset;
+    short scaled_ref_layer_bottom_offset;
+    unsigned short Reserved16Bits;
+    struct _CUVIDPICPARAMS *pNextLayer; /**< Points to the picparams for the next layer to be decoded. Linked list ends at the target layer. */
+    int bRefBaseLayer;                  /**< whether to store ref base pic */
+} CUVIDH264SVCEXT;
+
+/*!
+ * \struct CUVIDH264PICPARAMS
+ * H.264 Picture Parameters
+ */
+typedef struct _CUVIDH264PICPARAMS
+{
+    // SPS
+    int log2_max_frame_num_minus4;
+    int pic_order_cnt_type;
+    int log2_max_pic_order_cnt_lsb_minus4;
+    int delta_pic_order_always_zero_flag;
+    int frame_mbs_only_flag;
+    int direct_8x8_inference_flag;
+    int num_ref_frames;             // NOTE: shall meet level 4.1 restrictions
+    unsigned char residual_colour_transform_flag;
+    unsigned char bit_depth_luma_minus8;    // Must be 0 (only 8-bit supported)
+    unsigned char bit_depth_chroma_minus8;  // Must be 0 (only 8-bit supported)
+    unsigned char qpprime_y_zero_transform_bypass_flag;
+    // PPS
+    int entropy_coding_mode_flag;
+    int pic_order_present_flag;
+    int num_ref_idx_l0_active_minus1;
+    int num_ref_idx_l1_active_minus1;
+    int weighted_pred_flag;
+    int weighted_bipred_idc;
+    int pic_init_qp_minus26;
+    int deblocking_filter_control_present_flag;
+    int redundant_pic_cnt_present_flag;
+    int transform_8x8_mode_flag;
+    int MbaffFrameFlag;
+    int constrained_intra_pred_flag;
+    int chroma_qp_index_offset;
+    int second_chroma_qp_index_offset;
+    int ref_pic_flag;
+    int frame_num;
+    int CurrFieldOrderCnt[2];
+    // DPB
+    CUVIDH264DPBENTRY dpb[16];          // List of reference frames within the DPB
+    // Quantization Matrices (raster-order)
+    unsigned char WeightScale4x4[6][16];
+    unsigned char WeightScale8x8[2][64];
+    // FMO/ASO
+    unsigned char fmo_aso_enable;
+    unsigned char num_slice_groups_minus1;
+    unsigned char slice_group_map_type;
+    signed char pic_init_qs_minus26;
+    unsigned int slice_group_change_rate_minus1;
+    union
+    {
+        unsigned long long slice_group_map_addr;
+        const unsigned char *pMb2SliceGroupMap;
+    } fmo;
+    unsigned int  Reserved[12];
+    // SVC/MVC
+    union
+    {
+        CUVIDH264MVCEXT mvcext;
+        CUVIDH264SVCEXT svcext;
+    } svcmvc;
+} CUVIDH264PICPARAMS;
+
+
+/*!
+ * \struct CUVIDMPEG2PICPARAMS
+ * MPEG-2 Picture Parameters
+ */
+typedef struct _CUVIDMPEG2PICPARAMS
+{
+    int ForwardRefIdx;          // Picture index of forward reference (P/B-frames)
+    int BackwardRefIdx;         // Picture index of backward reference (B-frames)
+    int picture_coding_type;
+    int full_pel_forward_vector;
+    int full_pel_backward_vector;
+    int f_code[2][2];
+    int intra_dc_precision;
+    int frame_pred_frame_dct;
+    int concealment_motion_vectors;
+    int q_scale_type;
+    int intra_vlc_format;
+    int alternate_scan;
+    int top_field_first;
+    // Quantization matrices (raster order)
+    unsigned char QuantMatrixIntra[64];
+    unsigned char QuantMatrixInter[64];
+} CUVIDMPEG2PICPARAMS;
+
+////////////////////////////////////////////////////////////////////////////////////////////////
+//
+// MPEG-4 Picture Parameters
+//
+
+// MPEG-4 has VOP types instead of Picture types
+#define I_VOP 0
+#define P_VOP 1
+#define B_VOP 2
+#define S_VOP 3
+
+/*!
+ * \struct CUVIDMPEG4PICPARAMS
+ * MPEG-4 Picture Parameters
+ */
+typedef struct _CUVIDMPEG4PICPARAMS
+{
+    int ForwardRefIdx;          // Picture index of forward reference (P/B-frames)
+    int BackwardRefIdx;         // Picture index of backward reference (B-frames)
+    // VOL
+    int video_object_layer_width;
+    int video_object_layer_height;
+    int vop_time_increment_bitcount;
+    int top_field_first;
+    int resync_marker_disable;
+    int quant_type;
+    int quarter_sample;
+    int short_video_header;
+    int divx_flags;
+    // VOP
+    int vop_coding_type;
+    int vop_coded;
+    int vop_rounding_type;
+    int alternate_vertical_scan_flag;
+    int interlaced;
+    int vop_fcode_forward;
+    int vop_fcode_backward;
+    int trd[2];
+    int trb[2];
+    // Quantization matrices (raster order)
+    unsigned char QuantMatrixIntra[64];
+    unsigned char QuantMatrixInter[64];
+    int gmc_enabled;
+} CUVIDMPEG4PICPARAMS;
+
+/*!
+ * \struct CUVIDVC1PICPARAMS
+ * VC1 Picture Parameters
+ */
+typedef struct _CUVIDVC1PICPARAMS
+{
+    int ForwardRefIdx;      /**< Picture index of forward reference (P/B-frames) */
+    int BackwardRefIdx;     /**< Picture index of backward reference (B-frames) */
+    int FrameWidth;         /**< Actual frame width */
+    int FrameHeight;        /**< Actual frame height */
+    // PICTURE
+    int intra_pic_flag;     /**< Set to 1 for I,BI frames */
+    int ref_pic_flag;       /**< Set to 1 for I,P frames */
+    int progressive_fcm;    /**< Progressive frame */
+    // SEQUENCE
+    int profile;
+    int postprocflag;
+    int pulldown;
+    int interlace;
+    int tfcntrflag;
+    int finterpflag;
+    int psf;
+    int multires;
+    int syncmarker;
+    int rangered;
+    int maxbframes;
+    // ENTRYPOINT
+    int panscan_flag;
+    int refdist_flag;
+    int extended_mv;
+    int dquant;
+    int vstransform;
+    int loopfilter;
+    int fastuvmc;
+    int overlap;
+    int quantizer;
+    int extended_dmv;
+    int range_mapy_flag;
+    int range_mapy;
+    int range_mapuv_flag;
+    int range_mapuv;
+    int rangeredfrm;    // range reduction state
+} CUVIDVC1PICPARAMS;
+
+/*!
+ * \struct CUVIDJPEGPICPARAMS
+ * JPEG Picture Parameters
+ */
+typedef struct _CUVIDJPEGPICPARAMS
+{
+    int Reserved;
+} CUVIDJPEGPICPARAMS;
+
+
+ /*!
+ * \struct CUVIDHEVCPICPARAMS
+ * HEVC Picture Parameters
+ */
+typedef struct _CUVIDHEVCPICPARAMS
+{
+    // sps
+    int pic_width_in_luma_samples;
+    int pic_height_in_luma_samples;
+    unsigned char log2_min_luma_coding_block_size_minus3;
+    unsigned char log2_diff_max_min_luma_coding_block_size;
+    unsigned char log2_min_transform_block_size_minus2;
+    unsigned char log2_diff_max_min_transform_block_size;
+    unsigned char pcm_enabled_flag;
+    unsigned char log2_min_pcm_luma_coding_block_size_minus3;
+    unsigned char log2_diff_max_min_pcm_luma_coding_block_size;
+    unsigned char pcm_sample_bit_depth_luma_minus1;
+
+    unsigned char pcm_sample_bit_depth_chroma_minus1;
+    unsigned char pcm_loop_filter_disabled_flag;
+    unsigned char strong_intra_smoothing_enabled_flag;
+    unsigned char max_transform_hierarchy_depth_intra;
+    unsigned char max_transform_hierarchy_depth_inter;
+    unsigned char amp_enabled_flag;
+    unsigned char separate_colour_plane_flag;
+    unsigned char log2_max_pic_order_cnt_lsb_minus4;
+
+    unsigned char num_short_term_ref_pic_sets;
+    unsigned char long_term_ref_pics_present_flag;
+    unsigned char num_long_term_ref_pics_sps;
+    unsigned char sps_temporal_mvp_enabled_flag;
+    unsigned char sample_adaptive_offset_enabled_flag;
+    unsigned char scaling_list_enable_flag;
+    unsigned char IrapPicFlag;
+    unsigned char IdrPicFlag;
+
+    unsigned char bit_depth_luma_minus8;
+    unsigned char bit_depth_chroma_minus8;
+    unsigned char reserved1[14];
+
+    // pps
+    unsigned char dependent_slice_segments_enabled_flag;
+    unsigned char slice_segment_header_extension_present_flag;
+    unsigned char sign_data_hiding_enabled_flag;
+    unsigned char cu_qp_delta_enabled_flag;
+    unsigned char diff_cu_qp_delta_depth;
+    signed char init_qp_minus26;
+    signed char pps_cb_qp_offset;
+    signed char pps_cr_qp_offset;
+
+    unsigned char constrained_intra_pred_flag;
+    unsigned char weighted_pred_flag;
+    unsigned char weighted_bipred_flag;
+    unsigned char transform_skip_enabled_flag;
+    unsigned char transquant_bypass_enabled_flag;
+    unsigned char entropy_coding_sync_enabled_flag;
+    unsigned char log2_parallel_merge_level_minus2;
+    unsigned char num_extra_slice_header_bits;
+
+    unsigned char loop_filter_across_tiles_enabled_flag;
+    unsigned char loop_filter_across_slices_enabled_flag;
+    unsigned char output_flag_present_flag;
+    unsigned char num_ref_idx_l0_default_active_minus1;
+    unsigned char num_ref_idx_l1_default_active_minus1;
+    unsigned char lists_modification_present_flag;
+    unsigned char cabac_init_present_flag;
+    unsigned char pps_slice_chroma_qp_offsets_present_flag;
+
+    unsigned char deblocking_filter_override_enabled_flag;
+    unsigned char pps_deblocking_filter_disabled_flag;
+    signed char pps_beta_offset_div2;
+    signed char pps_tc_offset_div2;
+    unsigned char tiles_enabled_flag;
+    unsigned char uniform_spacing_flag;
+    unsigned char num_tile_columns_minus1;
+    unsigned char num_tile_rows_minus1;
+
+    unsigned short column_width_minus1[21];
+    unsigned short row_height_minus1[21];
+    unsigned int reserved3[15];
+
+    // RefPicSets
+    int NumBitsForShortTermRPSInSlice;
+    int NumDeltaPocsOfRefRpsIdx;
+    int NumPocTotalCurr;
+    int NumPocStCurrBefore;
+    int NumPocStCurrAfter;
+    int NumPocLtCurr;
+    int CurrPicOrderCntVal;
+    int RefPicIdx[16];                  // [refpic] Indices of valid reference pictures (-1 if unused for reference)
+    int PicOrderCntVal[16];             // [refpic]
+    unsigned char IsLongTerm[16];       // [refpic] 0=not a long-term reference, 1=long-term reference
+    unsigned char RefPicSetStCurrBefore[8]; // [0..NumPocStCurrBefore-1] -> refpic (0..15)
+    unsigned char RefPicSetStCurrAfter[8];  // [0..NumPocStCurrAfter-1] -> refpic (0..15)
+    unsigned char RefPicSetLtCurr[8];       // [0..NumPocLtCurr-1] -> refpic (0..15)
+    unsigned char RefPicSetInterLayer0[8];
+    unsigned char RefPicSetInterLayer1[8];
+    unsigned int reserved4[12];
+
+    // scaling lists (diag order)
+    unsigned char ScalingList4x4[6][16];       // [matrixId][i]
+    unsigned char ScalingList8x8[6][64];       // [matrixId][i]
+    unsigned char ScalingList16x16[6][64];     // [matrixId][i]
+    unsigned char ScalingList32x32[2][64];     // [matrixId][i]
+    unsigned char ScalingListDCCoeff16x16[6];  // [matrixId]
+    unsigned char ScalingListDCCoeff32x32[2];  // [matrixId]
+} CUVIDHEVCPICPARAMS;
+
+
+/*!
+ * \struct CUVIDVP8PICPARAMS
+ * VP8 Picture Parameters
+ */
+typedef struct _CUVIDVP8PICPARAMS
+{
+    int width;
+    int height;
+    unsigned int first_partition_size;
+    //Frame Indexes
+    unsigned char LastRefIdx;
+    unsigned char GoldenRefIdx;
+    unsigned char AltRefIdx;
+    union {
+        struct {
+            unsigned char frame_type : 1;    /**< 0 = KEYFRAME, 1 = INTERFRAME  */
+            unsigned char version : 3;
+            unsigned char show_frame : 1;
+            unsigned char update_mb_segmentation_data : 1;    /**< Must be 0 if segmentation is not enabled */
+            unsigned char Reserved2Bits : 2;
+        };
+        unsigned char wFrameTagFlags;
+    } tagflags;
+    unsigned char Reserved1[4];
+    unsigned int  Reserved2[3];
+} CUVIDVP8PICPARAMS;
+
+/*!
+ * \struct CUVIDVP9PICPARAMS
+ * VP9 Picture Parameters
+ */
+typedef struct _CUVIDVP9PICPARAMS
+{
+    unsigned int width;
+    unsigned int height;
+
+    //Frame Indices
+    unsigned char LastRefIdx;
+    unsigned char GoldenRefIdx;
+    unsigned char AltRefIdx;
+    unsigned char colorSpace;
+
+    unsigned short profile : 3;
+    unsigned short frameContextIdx : 2;
+    unsigned short frameType : 1;
+    unsigned short showFrame : 1;
+    unsigned short errorResilient : 1;
+    unsigned short frameParallelDecoding : 1;
+    unsigned short subSamplingX : 1;
+    unsigned short subSamplingY : 1;
+    unsigned short intraOnly : 1;
+    unsigned short allow_high_precision_mv : 1;
+    unsigned short refreshEntropyProbs : 1;
+    unsigned short reserved2Bits : 2;
+
+    unsigned short reserved16Bits;
+
+    unsigned char  refFrameSignBias[4];
+
+    unsigned char bitDepthMinus8Luma;
+    unsigned char bitDepthMinus8Chroma;
+    unsigned char loopFilterLevel;
+    unsigned char loopFilterSharpness;
+
+    unsigned char modeRefLfEnabled;
+    unsigned char log2_tile_columns;
+    unsigned char log2_tile_rows;
+
+    unsigned char segmentEnabled : 1;
+    unsigned char segmentMapUpdate : 1;
+    unsigned char segmentMapTemporalUpdate : 1;
+    unsigned char segmentFeatureMode : 1;
+    unsigned char reserved4Bits : 4;
+
+
+    unsigned char segmentFeatureEnable[8][4];
+    short segmentFeatureData[8][4];
+    unsigned char mb_segment_tree_probs[7];
+    unsigned char segment_pred_probs[3];
+    unsigned char reservedSegment16Bits[2];
+
+    int qpYAc;
+    int qpYDc;
+    int qpChDc;
+    int qpChAc;
+
+    unsigned int activeRefIdx[3];
+    unsigned int resetFrameContext;
+    unsigned int mcomp_filter_type;
+    unsigned int mbRefLfDelta[4];
+    unsigned int mbModeLfDelta[2];
+    unsigned int frameTagSize;
+    unsigned int offsetToDctParts;
+    unsigned int reserved128Bits[4];
+
+} CUVIDVP9PICPARAMS;
+
+
+/*!
+ * \struct CUVIDPICPARAMS
+ * Picture Parameters for Decoding
+ */
+typedef struct _CUVIDPICPARAMS
+{
+    int PicWidthInMbs;                    /**< Coded Frame Size */
+    int FrameHeightInMbs;                 /**< Coded Frame Height */
+    int CurrPicIdx;                       /**< Output index of the current picture */
+    int field_pic_flag;                   /**< 0=frame picture, 1=field picture */
+    int bottom_field_flag;                /**< 0=top field, 1=bottom field (ignored if field_pic_flag=0) */
+    int second_field;                     /**< Second field of a complementary field pair */
+    // Bitstream data
+    unsigned int nBitstreamDataLen;        /**< Number of bytes in bitstream data buffer */
+    const unsigned char *pBitstreamData;   /**< Ptr to bitstream data for this picture (slice-layer) */
+    unsigned int nNumSlices;               /**< Number of slices in this picture */
+    const unsigned int *pSliceDataOffsets; /**< nNumSlices entries, contains offset of each slice within the bitstream data buffer */
+    int ref_pic_flag;                      /**< This picture is a reference picture */
+    int intra_pic_flag;                    /**< This picture is entirely intra coded */
+    unsigned int Reserved[30];             /**< Reserved for future use */
+    // Codec-specific data
+    union {
+        CUVIDMPEG2PICPARAMS mpeg2;         /**< Also used for MPEG-1 */
+        CUVIDH264PICPARAMS h264;
+        CUVIDVC1PICPARAMS vc1;
+        CUVIDMPEG4PICPARAMS mpeg4;
+        CUVIDJPEGPICPARAMS jpeg;
+        CUVIDHEVCPICPARAMS hevc;
+        CUVIDVP8PICPARAMS vp8;
+        CUVIDVP9PICPARAMS vp9;
+        unsigned int CodecReserved[1024];
+    } CodecSpecific;
+} CUVIDPICPARAMS;
+
+
+/*!
+ * \struct CUVIDPROCPARAMS
+ * Picture Parameters for Postprocessing
+ */
+typedef struct _CUVIDPROCPARAMS
+{
+    int progressive_frame;  /**< Input is progressive (deinterlace_mode will be ignored)  */
+    int second_field;       /**< Output the second field (ignored if deinterlace mode is Weave) */
+    int top_field_first;    /**< Input frame is top field first (1st field is top, 2nd field is bottom) */
+    int unpaired_field;     /**< Input only contains one field (2nd field is invalid) */
+    // The fields below are used for raw YUV input
+    unsigned int reserved_flags;        /**< Reserved for future use (set to zero) */
+    unsigned int reserved_zero;         /**< Reserved (set to zero) */
+    unsigned long long raw_input_dptr;  /**< Input CUdeviceptr for raw YUV extensions */
+    unsigned int raw_input_pitch;       /**< pitch in bytes of raw YUV input (should be aligned appropriately) */
+    unsigned int raw_input_format;      /**< Reserved for future use (set to zero) */
+    unsigned long long raw_output_dptr; /**< Reserved for future use (set to zero) */
+    unsigned int raw_output_pitch;      /**< Reserved for future use (set to zero) */
+    unsigned int Reserved[48];
+    void *Reserved3[3];
+} CUVIDPROCPARAMS;
+
+
+/**
+ *
+ * In order to minimize decode latencies, there should be always at least 2 pictures in the decode
+ * queue at any time, in order to make sure that all decode engines are always busy.
+ *
+ * Overall data flow:
+ *  - cuvidCreateDecoder(...)
+ *  For each picture:
+ *  - cuvidDecodePicture(N)
+ *  - cuvidMapVideoFrame(N-4)
+ *  - do some processing in cuda
+ *  - cuvidUnmapVideoFrame(N-4)
+ *  - cuvidDecodePicture(N+1)
+ *  - cuvidMapVideoFrame(N-3)
+ *    ...
+ *  - cuvidDestroyDecoder(...)
+ *
+ * NOTE:
+ * - When the cuda context is created from a D3D device, the D3D device must also be created
+ *   with the D3DCREATE_MULTITHREADED flag.
+ * - There is a limit to how many pictures can be mapped simultaneously (ulNumOutputSurfaces)
+ * - cuVidDecodePicture may block the calling thread if there are too many pictures pending
+ *   in the decode queue
+ */
+
+/**
+ * \fn CUresult CUDAAPI cuvidCreateDecoder(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci)
+ * Create the decoder object
+ */
+typedef CUresult CUDAAPI tcuvidCreateDecoder(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci);
+
+/**
+ * \fn CUresult CUDAAPI cuvidDestroyDecoder(CUvideodecoder hDecoder)
+ * Destroy the decoder object
+ */
+typedef CUresult CUDAAPI tcuvidDestroyDecoder(CUvideodecoder hDecoder);
+
+/**
+ * \fn CUresult CUDAAPI cuvidDecodePicture(CUvideodecoder hDecoder, CUVIDPICPARAMS *pPicParams)
+ * Decode a single picture (field or frame)
+ */
+typedef CUresult CUDAAPI tcuvidDecodePicture(CUvideodecoder hDecoder, CUVIDPICPARAMS *pPicParams);
+
+
+#if !defined(__CUVID_DEVPTR64) || defined(__CUVID_INTERNAL)
+/**
+ * \fn CUresult CUDAAPI cuvidMapVideoFrame(CUvideodecoder hDecoder, int nPicIdx, unsigned int *pDevPtr, unsigned int *pPitch, CUVIDPROCPARAMS *pVPP);
+ * Post-process and map a video frame for use in cuda
+ */
+typedef CUresult CUDAAPI tcuvidMapVideoFrame(CUvideodecoder hDecoder, int nPicIdx,
+                                             unsigned int *pDevPtr, unsigned int *pPitch,
+                                             CUVIDPROCPARAMS *pVPP);
+
+/**
+ * \fn CUresult CUDAAPI cuvidUnmapVideoFrame(CUvideodecoder hDecoder, unsigned int DevPtr)
+ * Unmap a previously mapped video frame
+ */
+typedef CUresult CUDAAPI tcuvidUnmapVideoFrame(CUvideodecoder hDecoder, unsigned int DevPtr);
+#endif
+
+#if defined(WIN64) || defined(_WIN64) || defined(__x86_64) || defined(AMD64) || defined(_M_AMD64)
+/**
+ * \fn CUresult CUDAAPI cuvidMapVideoFrame64(CUvideodecoder hDecoder, int nPicIdx, unsigned long long *pDevPtr, unsigned int *pPitch, CUVIDPROCPARAMS *pVPP);
+ * map a video frame
+ */
+typedef CUresult CUDAAPI tcuvidMapVideoFrame64(CUvideodecoder hDecoder, int nPicIdx, unsigned long long *pDevPtr,
+                                               unsigned int *pPitch, CUVIDPROCPARAMS *pVPP);
+
+/**
+ * \fn CUresult CUDAAPI cuvidUnmapVideoFrame64(CUvideodecoder hDecoder, unsigned long long DevPtr);
+ * Unmap a previously mapped video frame
+ */
+typedef CUresult CUDAAPI tcuvidUnmapVideoFrame64(CUvideodecoder hDecoder, unsigned long long DevPtr);
+
+#if defined(__CUVID_DEVPTR64) && !defined(__CUVID_INTERNAL)
+#define tcuvidMapVideoFrame      tcuvidMapVideoFrame64
+#define tcuvidUnmapVideoFrame    tcuvidUnmapVideoFrame64
+#endif
+#endif
+
+
+/**
+ *
+ * Context-locking: to facilitate multi-threaded implementations, the following 4 functions
+ * provide a simple mutex-style host synchronization. If a non-NULL context is specified
+ * in CUVIDDECODECREATEINFO, the codec library will acquire the mutex associated with the given
+ * context before making any cuda calls.
+ * A multi-threaded application could create a lock associated with a context handle so that
+ * multiple threads can safely share the same cuda context:
+ *  - use cuCtxPopCurrent immediately after context creation in order to create a 'floating' context
+ *    that can be passed to cuvidCtxLockCreate.
+ *  - When using a floating context, all cuda calls should only be made within a cuvidCtxLock/cuvidCtxUnlock section.
+ *
+ * NOTE: This is a safer alternative to cuCtxPushCurrent and cuCtxPopCurrent, and is not related to video
+ * decoder in any way (implemented as a critical section associated with cuCtx{Push|Pop}Current calls).
+*/
+
+/**
+ * \fn CUresult CUDAAPI cuvidCtxLockCreate(CUvideoctxlock *pLock, CUcontext ctx)
+ */
+typedef CUresult CUDAAPI tcuvidCtxLockCreate(CUvideoctxlock *pLock, CUcontext ctx);
+
+/**
+ * \fn CUresult CUDAAPI cuvidCtxLockDestroy(CUvideoctxlock lck)
+ */
+typedef CUresult CUDAAPI tcuvidCtxLockDestroy(CUvideoctxlock lck);
+
+/**
+ * \fn CUresult CUDAAPI cuvidCtxLock(CUvideoctxlock lck, unsigned int reserved_flags)
+ */
+typedef CUresult CUDAAPI tcuvidCtxLock(CUvideoctxlock lck, unsigned int reserved_flags);
+
+/**
+ * \fn CUresult CUDAAPI cuvidCtxUnlock(CUvideoctxlock lck, unsigned int reserved_flags)
+ */
+typedef CUresult CUDAAPI tcuvidCtxUnlock(CUvideoctxlock lck, unsigned int reserved_flags);
+
+/** @} */  /* End VIDEO_DECODER */
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif // __CUDA_VIDEO_H__
diff --git a/compat/cuda/dynlink_loader.h b/compat/cuda/dynlink_loader.h
new file mode 100644
index 0000000..9c4809d
--- /dev/null
+++ b/compat/cuda/dynlink_loader.h
@@ -0,0 +1,263 @@
+/*
+ * This copyright notice applies to this header file only:
+ *
+ * Copyright (c) 2016
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the software, and to permit persons to whom the
+ * software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef AV_COMPAT_CUDA_DYNLINK_LOADER_H
+#define AV_COMPAT_CUDA_DYNLINK_LOADER_H
+
+#include "compat/cuda/dynlink_cuda.h"
+#include "compat/cuda/dynlink_nvcuvid.h"
+#include "compat/nvenc/nvEncodeAPI.h"
+
+#include "libavutil/log.h"
+#include "libavutil/error.h"
+
+#if defined(_WIN32)
+# include <windows.h>
+# define dlopen(filename, flags) LoadLibrary(TEXT(filename))
+# define dlsym(handle, symbol) GetProcAddress(handle, symbol)
+# define dlclose(handle) FreeLibrary(handle)
+# define LIB_HANDLE HMODULE
+#else
+# include <dlfcn.h>
+# define LIB_HANDLE void*
+#endif
+
+#if defined(_WIN32) || defined(__CYGWIN__)
+# define CUDA_LIBNAME "nvcuda.dll"
+# define NVCUVID_LIBNAME "nvcuvid.dll"
+# if ARCH_X86_64
+#  define NVENC_LIBNAME "nvEncodeAPI64.dll"
+# else
+#  define NVENC_LIBNAME "nvEncodeAPI.dll"
+# endif
+#else
+# define CUDA_LIBNAME "libcuda.so.1"
+# define NVCUVID_LIBNAME "libnvcuvid.so.1"
+# define NVENC_LIBNAME "libnvidia-encode.so.1"
+#endif
+
+#define LOAD_LIBRARY(l, path)                                     \
+    do {                                                          \
+        if (!((l) = dlopen(path, RTLD_LAZY))) {                   \
+            av_log(NULL, AV_LOG_ERROR, "Cannot load %s\n", path); \
+            ret = AVERROR_UNKNOWN;                                \
+            goto error;                                           \
+        }                                                         \
+        av_log(NULL, AV_LOG_TRACE, "Loaded lib: %s\n", path);     \
+    } while (0)
+
+#define LOAD_SYMBOL(fun, symbol)                                    \
+    do {                                                            \
+        if (!((f->fun) = dlsym(f->lib, symbol))) {                  \
+            av_log(NULL, AV_LOG_ERROR, "Cannot load %s\n", symbol); \
+            ret = AVERROR_UNKNOWN;                                  \
+            goto error;                                             \
+        }                                                           \
+        av_log(NULL, AV_LOG_TRACE, "Loaded sym: %s\n", symbol);     \
+    } while (0)
+
+#define GENERIC_LOAD_FUNC_PREAMBLE(T, n, N)  \
+    T *f;                                    \
+    int ret;                                 \
+                                             \
+    n##_free_functions(functions);           \
+                                             \
+    f = *functions = av_mallocz(sizeof(*f)); \
+    if (!f)                                  \
+        return AVERROR(ENOMEM);              \
+                                             \
+    LOAD_LIBRARY(f->lib, N);
+
+#define GENERIC_LOAD_FUNC_FINALE(n) \
+    return 0;                       \
+error:                              \
+    n##_free_functions(functions);  \
+    return ret;
+
+#define GENERIC_FREE_FUNC()              \
+    if (!functions)                      \
+        return;                          \
+    if (*functions && (*functions)->lib) \
+        dlclose((*functions)->lib);      \
+    av_freep(functions);
+
+#ifdef AV_COMPAT_DYNLINK_CUDA_H
+typedef struct CudaFunctions {
+    tcuInit *cuInit;
+    tcuDeviceGetCount *cuDeviceGetCount;
+    tcuDeviceGet *cuDeviceGet;
+    tcuDeviceGetName *cuDeviceGetName;
+    tcuDeviceComputeCapability *cuDeviceComputeCapability;
+    tcuCtxCreate_v2 *cuCtxCreate;
+    tcuCtxPushCurrent_v2 *cuCtxPushCurrent;
+    tcuCtxPopCurrent_v2 *cuCtxPopCurrent;
+    tcuCtxDestroy_v2 *cuCtxDestroy;
+    tcuMemAlloc_v2 *cuMemAlloc;
+    tcuMemFree_v2 *cuMemFree;
+    tcuMemcpy2D_v2 *cuMemcpy2D;
+    tcuGetErrorName *cuGetErrorName;
+    tcuGetErrorString *cuGetErrorString;
+
+    LIB_HANDLE lib;
+} CudaFunctions;
+#else
+typedef struct CudaFunctions CudaFunctions;
+#endif
+
+typedef struct CuvidFunctions {
+    tcuvidCreateDecoder *cuvidCreateDecoder;
+    tcuvidDestroyDecoder *cuvidDestroyDecoder;
+    tcuvidDecodePicture *cuvidDecodePicture;
+    tcuvidMapVideoFrame *cuvidMapVideoFrame;
+    tcuvidUnmapVideoFrame *cuvidUnmapVideoFrame;
+    tcuvidCtxLockCreate *cuvidCtxLockCreate;
+    tcuvidCtxLockDestroy *cuvidCtxLockDestroy;
+    tcuvidCtxLock *cuvidCtxLock;
+    tcuvidCtxUnlock *cuvidCtxUnlock;
+
+    tcuvidCreateVideoSource *cuvidCreateVideoSource;
+    tcuvidCreateVideoSourceW *cuvidCreateVideoSourceW;
+    tcuvidDestroyVideoSource *cuvidDestroyVideoSource;
+    tcuvidSetVideoSourceState *cuvidSetVideoSourceState;
+    tcuvidGetVideoSourceState *cuvidGetVideoSourceState;
+    tcuvidGetSourceVideoFormat *cuvidGetSourceVideoFormat;
+    tcuvidGetSourceAudioFormat *cuvidGetSourceAudioFormat;
+    tcuvidCreateVideoParser *cuvidCreateVideoParser;
+    tcuvidParseVideoData *cuvidParseVideoData;
+    tcuvidDestroyVideoParser *cuvidDestroyVideoParser;
+
+    LIB_HANDLE lib;
+} CuvidFunctions;
+
+typedef struct NvencFunctions {
+    NVENCSTATUS (NVENCAPI *NvEncodeAPICreateInstance)(NV_ENCODE_API_FUNCTION_LIST *functionList);
+    NVENCSTATUS (NVENCAPI *NvEncodeAPIGetMaxSupportedVersion)(uint32_t* version);
+
+    LIB_HANDLE lib;
+} NvencFunctions;
+
+#ifdef AV_COMPAT_DYNLINK_CUDA_H
+static inline void cuda_free_functions(CudaFunctions **functions)
+{
+    GENERIC_FREE_FUNC();
+}
+#endif
+
+static inline void cuvid_free_functions(CuvidFunctions **functions)
+{
+    GENERIC_FREE_FUNC();
+}
+
+static inline void nvenc_free_functions(NvencFunctions **functions)
+{
+    GENERIC_FREE_FUNC();
+}
+
+#ifdef AV_COMPAT_DYNLINK_CUDA_H
+static inline int cuda_load_functions(CudaFunctions **functions)
+{
+    GENERIC_LOAD_FUNC_PREAMBLE(CudaFunctions, cuda, CUDA_LIBNAME);
+
+    LOAD_SYMBOL(cuInit, "cuInit");
+    LOAD_SYMBOL(cuDeviceGetCount, "cuDeviceGetCount");
+    LOAD_SYMBOL(cuDeviceGet, "cuDeviceGet");
+    LOAD_SYMBOL(cuDeviceGetName, "cuDeviceGetName");
+    LOAD_SYMBOL(cuDeviceComputeCapability, "cuDeviceComputeCapability");
+    LOAD_SYMBOL(cuCtxCreate, "cuCtxCreate_v2");
+    LOAD_SYMBOL(cuCtxPushCurrent, "cuCtxPushCurrent_v2");
+    LOAD_SYMBOL(cuCtxPopCurrent, "cuCtxPopCurrent_v2");
+    LOAD_SYMBOL(cuCtxDestroy, "cuCtxDestroy_v2");
+    LOAD_SYMBOL(cuMemAlloc, "cuMemAlloc_v2");
+    LOAD_SYMBOL(cuMemFree, "cuMemFree_v2");
+    LOAD_SYMBOL(cuMemcpy2D, "cuMemcpy2D_v2");
+    LOAD_SYMBOL(cuGetErrorName, "cuGetErrorName");
+    LOAD_SYMBOL(cuGetErrorString, "cuGetErrorString");
+
+    GENERIC_LOAD_FUNC_FINALE(cuda);
+}
+#endif
+
+static inline int cuvid_load_functions(CuvidFunctions **functions)
+{
+    GENERIC_LOAD_FUNC_PREAMBLE(CuvidFunctions, cuvid, NVCUVID_LIBNAME);
+
+    LOAD_SYMBOL(cuvidCreateDecoder, "cuvidCreateDecoder");
+    LOAD_SYMBOL(cuvidDestroyDecoder, "cuvidDestroyDecoder");
+    LOAD_SYMBOL(cuvidDecodePicture, "cuvidDecodePicture");
+#ifdef __CUVID_DEVPTR64
+    LOAD_SYMBOL(cuvidMapVideoFrame, "cuvidMapVideoFrame64");
+    LOAD_SYMBOL(cuvidUnmapVideoFrame, "cuvidUnmapVideoFrame64");
+#else
+    LOAD_SYMBOL(cuvidMapVideoFrame, "cuvidMapVideoFrame");
+    LOAD_SYMBOL(cuvidUnmapVideoFrame, "cuvidUnmapVideoFrame");
+#endif
+    LOAD_SYMBOL(cuvidCtxLockCreate, "cuvidCtxLockCreate");
+    LOAD_SYMBOL(cuvidCtxLockDestroy, "cuvidCtxLockDestroy");
+    LOAD_SYMBOL(cuvidCtxLock, "cuvidCtxLock");
+    LOAD_SYMBOL(cuvidCtxUnlock, "cuvidCtxUnlock");
+
+    LOAD_SYMBOL(cuvidCreateVideoSource, "cuvidCreateVideoSource");
+    LOAD_SYMBOL(cuvidCreateVideoSourceW, "cuvidCreateVideoSourceW");
+    LOAD_SYMBOL(cuvidDestroyVideoSource, "cuvidDestroyVideoSource");
+    LOAD_SYMBOL(cuvidSetVideoSourceState, "cuvidSetVideoSourceState");
+    LOAD_SYMBOL(cuvidGetVideoSourceState, "cuvidGetVideoSourceState");
+    LOAD_SYMBOL(cuvidGetSourceVideoFormat, "cuvidGetSourceVideoFormat");
+    LOAD_SYMBOL(cuvidGetSourceAudioFormat, "cuvidGetSourceAudioFormat");
+    LOAD_SYMBOL(cuvidCreateVideoParser, "cuvidCreateVideoParser");
+    LOAD_SYMBOL(cuvidParseVideoData, "cuvidParseVideoData");
+    LOAD_SYMBOL(cuvidDestroyVideoParser, "cuvidDestroyVideoParser");
+
+    GENERIC_LOAD_FUNC_FINALE(cuvid);
+}
+
+static inline int nvenc_load_functions(NvencFunctions **functions)
+{
+    GENERIC_LOAD_FUNC_PREAMBLE(NvencFunctions, nvenc, NVENC_LIBNAME);
+
+    LOAD_SYMBOL(NvEncodeAPICreateInstance, "NvEncodeAPICreateInstance");
+    LOAD_SYMBOL(NvEncodeAPIGetMaxSupportedVersion, "NvEncodeAPIGetMaxSupportedVersion");
+
+    GENERIC_LOAD_FUNC_FINALE(nvenc);
+}
+
+#undef GENERIC_LOAD_FUNC_PREAMBLE
+#undef LOAD_LIBRARY
+#undef LOAD_SYMBOL
+#undef GENERIC_LOAD_FUNC_FINALE
+#undef GENERIC_FREE_FUNC
+#undef CUDA_LIBNAME
+#undef NVCUVID_LIBNAME
+#undef NVENC_LIBNAME
+#undef LIB_HANDLE
+
+#if defined(_WIN32)
+#undef dlopen
+#undef dlsym
+#undef dlclose
+#endif
+
+#endif
\ No newline at end of file
diff --git a/compat/cuda/dynlink_nvcuvid.h b/compat/cuda/dynlink_nvcuvid.h
new file mode 100644
index 0000000..6c197e0
--- /dev/null
+++ b/compat/cuda/dynlink_nvcuvid.h
@@ -0,0 +1,316 @@
+/*
+ * This copyright notice applies to this header file only:
+ *
+ * Copyright (c) 2010-2016 NVIDIA Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the software, and to permit persons to whom the
+ * software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file nvcuvid.h
+ *   NvCuvid API provides Video Decoding interface to NVIDIA GPU devices.
+ * \date 2015-2015
+ *  This file contains the interface constants, structure definitions and function prototypes.
+ */
+
+#if !defined(__NVCUVID_H__)
+#define __NVCUVID_H__
+
+#include "compat/cuda/dynlink_cuviddec.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif /* __cplusplus */
+
+////////////////////////////////////////////////////////////////////////////////////////////////
+//
+// High-level helper APIs for video sources
+//
+
+typedef void *CUvideosource;
+typedef void *CUvideoparser;
+typedef long long CUvideotimestamp;
+
+/**
+ * \addtogroup VIDEO_PARSER Video Parser
+ * @{
+ */
+
+/*!
+ * \enum cudaVideoState
+ * Video Source State
+ */
+typedef enum {
+    cudaVideoState_Error   = -1,    /**< Error state (invalid source)  */
+    cudaVideoState_Stopped = 0,     /**< Source is stopped (or reached end-of-stream)  */
+    cudaVideoState_Started = 1      /**< Source is running and delivering data  */
+} cudaVideoState;
+
+/*!
+ * \enum cudaAudioCodec
+ * Audio compression
+ */
+typedef enum {
+    cudaAudioCodec_MPEG1=0,         /**< MPEG-1 Audio  */
+    cudaAudioCodec_MPEG2,           /**< MPEG-2 Audio  */
+    cudaAudioCodec_MP3,             /**< MPEG-1 Layer III Audio  */
+    cudaAudioCodec_AC3,             /**< Dolby Digital (AC3) Audio  */
+    cudaAudioCodec_LPCM             /**< PCM Audio  */
+} cudaAudioCodec;
+
+/*!
+ * \struct CUVIDEOFORMAT
+ * Video format
+ */
+typedef struct
+{
+    cudaVideoCodec codec;                   /**< Compression format  */
+   /**
+    * frame rate = numerator / denominator (for example: 30000/1001)
+    */
+    struct {
+        unsigned int numerator;             /**< frame rate numerator   (0 = unspecified or variable frame rate) */
+        unsigned int denominator;           /**< frame rate denominator (0 = unspecified or variable frame rate) */
+    } frame_rate;
+    unsigned char progressive_sequence;     /**< 0=interlaced, 1=progressive */
+    unsigned char bit_depth_luma_minus8;    /**< high bit depth Luma */
+    unsigned char bit_depth_chroma_minus8;  /**< high bit depth Chroma */
+    unsigned char reserved1;                /**< Reserved for future use */
+    unsigned int coded_width;               /**< coded frame width */
+    unsigned int coded_height;              /**< coded frame height  */
+   /**
+    *   area of the frame that should be displayed
+    * typical example:
+    *   coded_width = 1920, coded_height = 1088
+    *   display_area = { 0,0,1920,1080 }
+    */
+    struct {
+        int left;                           /**< left position of display rect  */
+        int top;                            /**< top position of display rect  */
+        int right;                          /**< right position of display rect  */
+        int bottom;                         /**< bottom position of display rect  */
+    } display_area;
+    cudaVideoChromaFormat chroma_format;    /**<  Chroma format */
+    unsigned int bitrate;                   /**< video bitrate (bps, 0=unknown) */
+   /**
+    * Display Aspect Ratio = x:y (4:3, 16:9, etc)
+    */
+    struct {
+        int x;
+        int y;
+    } display_aspect_ratio;
+    /**
+    * Video Signal Description
+    */
+    struct {
+        unsigned char video_format          : 3;
+        unsigned char video_full_range_flag : 1;
+        unsigned char reserved_zero_bits    : 4;
+        unsigned char color_primaries;
+        unsigned char transfer_characteristics;
+        unsigned char matrix_coefficients;
+    } video_signal_description;
+    unsigned int seqhdr_data_length;          /**< Additional bytes following (CUVIDEOFORMATEX)  */
+} CUVIDEOFORMAT;
+
+/*!
+ * \struct CUVIDEOFORMATEX
+ * Video format including raw sequence header information
+ */
+typedef struct
+{
+    CUVIDEOFORMAT format;
+    unsigned char raw_seqhdr_data[1024];
+} CUVIDEOFORMATEX;
+
+/*!
+ * \struct CUAUDIOFORMAT
+ * Audio Formats
+ */
+typedef struct
+{
+    cudaAudioCodec codec;       /**< Compression format  */
+    unsigned int channels;      /**< number of audio channels */
+    unsigned int samplespersec; /**< sampling frequency */
+    unsigned int bitrate;       /**< For uncompressed, can also be used to determine bits per sample */
+    unsigned int reserved1;     /**< Reserved for future use */
+    unsigned int reserved2;     /**< Reserved for future use */
+} CUAUDIOFORMAT;
+
+
+/*!
+ * \enum CUvideopacketflags
+ * Data packet flags
+ */
+typedef enum {
+    CUVID_PKT_ENDOFSTREAM   = 0x01,   /**< Set when this is the last packet for this stream  */
+    CUVID_PKT_TIMESTAMP     = 0x02,   /**< Timestamp is valid  */
+    CUVID_PKT_DISCONTINUITY = 0x04    /**< Set when a discontinuity has to be signalled  */
+} CUvideopacketflags;
+
+/*!
+ * \struct CUVIDSOURCEDATAPACKET
+ * Data Packet
+ */
+typedef struct _CUVIDSOURCEDATAPACKET
+{
+    unsigned long flags;            /**< Combination of CUVID_PKT_XXX flags */
+    unsigned long payload_size;     /**< number of bytes in the payload (may be zero if EOS flag is set) */
+    const unsigned char *payload;   /**< Pointer to packet payload data (may be NULL if EOS flag is set) */
+    CUvideotimestamp timestamp;     /**< Presentation timestamp (10MHz clock), only valid if CUVID_PKT_TIMESTAMP flag is set */
+} CUVIDSOURCEDATAPACKET;
+
+// Callback for packet delivery
+typedef int (CUDAAPI *PFNVIDSOURCECALLBACK)(void *, CUVIDSOURCEDATAPACKET *);
+
+/*!
+ * \struct CUVIDSOURCEPARAMS
+ * Source Params
+ */
+typedef struct _CUVIDSOURCEPARAMS
+{
+    unsigned int ulClockRate;                   /**< Timestamp units in Hz (0=default=10000000Hz)  */
+    unsigned int uReserved1[7];                 /**< Reserved for future use - set to zero  */
+    void *pUserData;                            /**< Parameter passed in to the data handlers  */
+    PFNVIDSOURCECALLBACK pfnVideoDataHandler;   /**< Called to deliver audio packets  */
+    PFNVIDSOURCECALLBACK pfnAudioDataHandler;   /**< Called to deliver video packets  */
+    void *pvReserved2[8];                       /**< Reserved for future use - set to NULL */
+} CUVIDSOURCEPARAMS;
+
+/*!
+ * \enum CUvideosourceformat_flags
+ * CUvideosourceformat_flags
+ */
+typedef enum {
+    CUVID_FMT_EXTFORMATINFO = 0x100             /**< Return extended format structure (CUVIDEOFORMATEX) */
+} CUvideosourceformat_flags;
+
+#if !defined(__APPLE__)
+/**
+ * \fn CUresult CUDAAPI cuvidCreateVideoSource(CUvideosource *pObj, const char *pszFileName, CUVIDSOURCEPARAMS *pParams)
+ * Create Video Source
+ */
+typedef CUresult CUDAAPI tcuvidCreateVideoSource(CUvideosource *pObj, const char *pszFileName, CUVIDSOURCEPARAMS *pParams);
+
+/**
+ * \fn CUresult CUDAAPI cuvidCreateVideoSourceW(CUvideosource *pObj, const wchar_t *pwszFileName, CUVIDSOURCEPARAMS *pParams)
+ * Create Video Source
+ */
+typedef CUresult CUDAAPI tcuvidCreateVideoSourceW(CUvideosource *pObj, const wchar_t *pwszFileName, CUVIDSOURCEPARAMS *pParams);
+
+/**
+ * \fn CUresult CUDAAPI cuvidDestroyVideoSource(CUvideosource obj)
+ * Destroy Video Source
+ */
+typedef CUresult CUDAAPI tcuvidDestroyVideoSource(CUvideosource obj);
+
+/**
+ * \fn CUresult CUDAAPI cuvidSetVideoSourceState(CUvideosource obj, cudaVideoState state)
+ * Set Video Source state
+ */
+typedef CUresult CUDAAPI tcuvidSetVideoSourceState(CUvideosource obj, cudaVideoState state);
+
+/**
+ * \fn cudaVideoState CUDAAPI cuvidGetVideoSourceState(CUvideosource obj)
+ * Get Video Source state
+ */
+typedef cudaVideoState CUDAAPI tcuvidGetVideoSourceState(CUvideosource obj);
+
+/**
+ * \fn CUresult CUDAAPI cuvidGetSourceVideoFormat(CUvideosource obj, CUVIDEOFORMAT *pvidfmt, unsigned int flags)
+ * Get Video Source Format
+ */
+typedef CUresult CUDAAPI tcuvidGetSourceVideoFormat(CUvideosource obj, CUVIDEOFORMAT *pvidfmt, unsigned int flags);
+
+/**
+ * \fn CUresult CUDAAPI cuvidGetSourceAudioFormat(CUvideosource obj, CUAUDIOFORMAT *paudfmt, unsigned int flags)
+ * Set Video Source state
+ */
+typedef CUresult CUDAAPI tcuvidGetSourceAudioFormat(CUvideosource obj, CUAUDIOFORMAT *paudfmt, unsigned int flags);
+
+#endif
+
+/**
+ * \struct CUVIDPARSERDISPINFO
+ */
+typedef struct _CUVIDPARSERDISPINFO
+{
+    int picture_index;         /**<                 */
+    int progressive_frame;     /**<                 */
+    int top_field_first;       /**<                 */
+    int repeat_first_field;    /**< Number of additional fields (1=ivtc, 2=frame doubling, 4=frame tripling, -1=unpaired field)  */
+    CUvideotimestamp timestamp; /**<     */
+} CUVIDPARSERDISPINFO;
+
+//
+// Parser callbacks
+// The parser will call these synchronously from within cuvidParseVideoData(), whenever a picture is ready to
+// be decoded and/or displayed.
+//
+typedef int (CUDAAPI *PFNVIDSEQUENCECALLBACK)(void *, CUVIDEOFORMAT *);
+typedef int (CUDAAPI *PFNVIDDECODECALLBACK)(void *, CUVIDPICPARAMS *);
+typedef int (CUDAAPI *PFNVIDDISPLAYCALLBACK)(void *, CUVIDPARSERDISPINFO *);
+
+/**
+ * \struct CUVIDPARSERPARAMS
+ */
+typedef struct _CUVIDPARSERPARAMS
+{
+    cudaVideoCodec CodecType;               /**< cudaVideoCodec_XXX  */
+    unsigned int ulMaxNumDecodeSurfaces;    /**< Max # of decode surfaces (parser will cycle through these) */
+    unsigned int ulClockRate;               /**< Timestamp units in Hz (0=default=10000000Hz) */
+    unsigned int ulErrorThreshold;          /**< % Error threshold (0-100) for calling pfnDecodePicture (100=always call pfnDecodePicture even if picture bitstream is fully corrupted) */
+    unsigned int ulMaxDisplayDelay;         /**< Max display queue delay (improves pipelining of decode with display) - 0=no delay (recommended values: 2..4) */
+    unsigned int uReserved1[5];             /**< Reserved for future use - set to 0 */
+    void *pUserData;                        /**< User data for callbacks */
+    PFNVIDSEQUENCECALLBACK pfnSequenceCallback; /**< Called before decoding frames and/or whenever there is a format change */
+    PFNVIDDECODECALLBACK pfnDecodePicture;      /**< Called when a picture is ready to be decoded (decode order) */
+    PFNVIDDISPLAYCALLBACK pfnDisplayPicture;    /**< Called whenever a picture is ready to be displayed (display order)  */
+    void *pvReserved2[7];                       /**< Reserved for future use - set to NULL */
+    CUVIDEOFORMATEX *pExtVideoInfo;             /**< [Optional] sequence header data from system layer */
+} CUVIDPARSERPARAMS;
+
+/**
+ * \fn CUresult CUDAAPI cuvidCreateVideoParser(CUvideoparser *pObj, CUVIDPARSERPARAMS *pParams)
+ */
+typedef CUresult CUDAAPI tcuvidCreateVideoParser(CUvideoparser *pObj, CUVIDPARSERPARAMS *pParams);
+
+/**
+ * \fn CUresult CUDAAPI cuvidParseVideoData(CUvideoparser obj, CUVIDSOURCEDATAPACKET *pPacket)
+ */
+typedef CUresult CUDAAPI tcuvidParseVideoData(CUvideoparser obj, CUVIDSOURCEDATAPACKET *pPacket);
+
+/**
+ * \fn CUresult CUDAAPI cuvidDestroyVideoParser(CUvideoparser obj)
+ */
+typedef CUresult CUDAAPI tcuvidDestroyVideoParser(CUvideoparser obj);
+
+/** @} */  /* END VIDEO_PARSER */
+////////////////////////////////////////////////////////////////////////////////////////////////
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif // __NVCUVID_H__
+
+
-- 
2.10.1


From aabd8588f22f72c18e8f62bc31b95d2b8806894a Mon Sep 17 00:00:00 2001
From: Timo Rothenpieler <timo@rothenpieler.org>
Date: Mon, 10 Oct 2016 12:52:40 +0200
Subject: [PATCH 2/8] avutil/hwcontext_cuda: use dynamically loaded CUDA

---
 configure                           |  2 +
 libavutil/hwcontext_cuda.c          | 99 ++++++++++++++++++++++++++++---------
 libavutil/hwcontext_cuda.h          |  5 ++
 libavutil/hwcontext_cuda_internal.h | 37 ++++++++++++++
 4 files changed, 119 insertions(+), 24 deletions(-)
 create mode 100644 libavutil/hwcontext_cuda_internal.h

diff --git a/configure b/configure
index 87b06f1..06cb5d2 100755
--- a/configure
+++ b/configure
@@ -2539,6 +2539,7 @@ audiotoolbox_extralibs="-framework CoreFoundation -framework AudioToolbox -frame
 
 # hardware accelerators
 crystalhd_deps="libcrystalhd_libcrystalhd_if_h"
+cuda_deps_any="dlopen LoadLibrary"
 cuvid_deps="cuda"
 d3d11va_deps="d3d11_h dxva_h ID3D11VideoDecoder ID3D11VideoContext"
 dxva2_deps="dxva2api_h DXVA2_ConfigPictureDecode"
@@ -5416,6 +5417,7 @@ elif check_func dlopen -ldl && check_func dlsym -ldl; then
 fi
 
 avisynth_demuxer_extralibs='$ldl'
+cuda_extralibs='$ldl'
 decklink_outdev_extralibs="$decklink_outdev_extralibs $ldl"
 decklink_indev_extralibs="$decklink_indev_extralibs $ldl"
 frei0r_filter_extralibs='$ldl'
diff --git a/libavutil/hwcontext_cuda.c b/libavutil/hwcontext_cuda.c
index e1dcab0..30de299 100644
--- a/libavutil/hwcontext_cuda.c
+++ b/libavutil/hwcontext_cuda.c
@@ -20,7 +20,7 @@
 #include "common.h"
 #include "hwcontext.h"
 #include "hwcontext_internal.h"
-#include "hwcontext_cuda.h"
+#include "hwcontext_cuda_internal.h"
 #include "mem.h"
 #include "pixdesc.h"
 #include "pixfmt.h"
@@ -41,44 +41,46 @@ static void cuda_buffer_free(void *opaque, uint8_t *data)
 {
     AVHWFramesContext *ctx = opaque;
     AVCUDADeviceContext *hwctx = ctx->device_ctx->hwctx;
+    CudaFunctions *cu = hwctx->internal->cuda_dl;
 
     CUcontext dummy;
 
-    cuCtxPushCurrent(hwctx->cuda_ctx);
+    cu->cuCtxPushCurrent(hwctx->cuda_ctx);
 
-    cuMemFree((CUdeviceptr)data);
+    cu->cuMemFree((CUdeviceptr)data);
 
-    cuCtxPopCurrent(&dummy);
+    cu->cuCtxPopCurrent(&dummy);
 }
 
 static AVBufferRef *cuda_pool_alloc(void *opaque, int size)
 {
     AVHWFramesContext     *ctx = opaque;
     AVCUDADeviceContext *hwctx = ctx->device_ctx->hwctx;
+    CudaFunctions          *cu = hwctx->internal->cuda_dl;
 
     AVBufferRef *ret = NULL;
     CUcontext dummy = NULL;
     CUdeviceptr data;
     CUresult err;
 
-    err = cuCtxPushCurrent(hwctx->cuda_ctx);
+    err = cu->cuCtxPushCurrent(hwctx->cuda_ctx);
     if (err != CUDA_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Error setting current CUDA context\n");
         return NULL;
     }
 
-    err = cuMemAlloc(&data, size);
+    err = cu->cuMemAlloc(&data, size);
     if (err != CUDA_SUCCESS)
         goto fail;
 
     ret = av_buffer_create((uint8_t*)data, size, cuda_buffer_free, ctx, 0);
     if (!ret) {
-        cuMemFree(data);
+        cu->cuMemFree(data);
         goto fail;
     }
 
 fail:
-    cuCtxPopCurrent(&dummy);
+    cu->cuCtxPopCurrent(&dummy);
     return ret;
 }
 
@@ -187,12 +189,13 @@ static int cuda_transfer_data_from(AVHWFramesContext *ctx, AVFrame *dst,
 {
     CUDAFramesContext           *priv = ctx->internal->priv;
     AVCUDADeviceContext *device_hwctx = ctx->device_ctx->hwctx;
+    CudaFunctions                 *cu = device_hwctx->internal->cuda_dl;
 
     CUcontext dummy;
     CUresult err;
     int i;
 
-    err = cuCtxPushCurrent(device_hwctx->cuda_ctx);
+    err = cu->cuCtxPushCurrent(device_hwctx->cuda_ctx);
     if (err != CUDA_SUCCESS)
         return AVERROR_UNKNOWN;
 
@@ -208,14 +211,14 @@ static int cuda_transfer_data_from(AVHWFramesContext *ctx, AVFrame *dst,
             .Height        = src->height >> (i ? priv->shift_height : 0),
         };
 
-        err = cuMemcpy2D(&cpy);
+        err = cu->cuMemcpy2D(&cpy);
         if (err != CUDA_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Error transferring the data from the CUDA frame\n");
             return AVERROR_UNKNOWN;
         }
     }
 
-    cuCtxPopCurrent(&dummy);
+    cu->cuCtxPopCurrent(&dummy);
 
     return 0;
 }
@@ -225,12 +228,13 @@ static int cuda_transfer_data_to(AVHWFramesContext *ctx, AVFrame *dst,
 {
     CUDAFramesContext           *priv = ctx->internal->priv;
     AVCUDADeviceContext *device_hwctx = ctx->device_ctx->hwctx;
+    CudaFunctions                 *cu = device_hwctx->internal->cuda_dl;
 
     CUcontext dummy;
     CUresult err;
     int i;
 
-    err = cuCtxPushCurrent(device_hwctx->cuda_ctx);
+    err = cu->cuCtxPushCurrent(device_hwctx->cuda_ctx);
     if (err != CUDA_SUCCESS)
         return AVERROR_UNKNOWN;
 
@@ -246,28 +250,64 @@ static int cuda_transfer_data_to(AVHWFramesContext *ctx, AVFrame *dst,
             .Height        = src->height >> (i ? priv->shift_height : 0),
         };
 
-        err = cuMemcpy2D(&cpy);
+        err = cu->cuMemcpy2D(&cpy);
         if (err != CUDA_SUCCESS) {
             av_log(ctx, AV_LOG_ERROR, "Error transferring the data from the CUDA frame\n");
             return AVERROR_UNKNOWN;
         }
     }
 
-    cuCtxPopCurrent(&dummy);
+    cu->cuCtxPopCurrent(&dummy);
 
     return 0;
 }
 
-static void cuda_device_free(AVHWDeviceContext *ctx)
+static void cuda_device_uninit(AVHWDeviceContext *ctx)
 {
     AVCUDADeviceContext *hwctx = ctx->hwctx;
-    cuCtxDestroy(hwctx->cuda_ctx);
+
+    if (hwctx->internal) {
+        if (hwctx->internal->is_allocated && hwctx->cuda_ctx) {
+            hwctx->internal->cuda_dl->cuCtxDestroy(hwctx->cuda_ctx);
+            hwctx->cuda_ctx = NULL;
+        }
+        cuda_free_functions(&hwctx->internal->cuda_dl);
+    }
+
+    av_freep(&hwctx->internal);
+}
+
+static int cuda_device_init(AVHWDeviceContext *ctx)
+{
+    AVCUDADeviceContext *hwctx = ctx->hwctx;
+    int ret;
+
+    if (!hwctx->internal) {
+        hwctx->internal = av_mallocz(sizeof(*hwctx->internal));
+        if (!hwctx->internal)
+            return AVERROR(ENOMEM);
+    }
+
+    if (!hwctx->internal->cuda_dl) {
+        ret = cuda_load_functions(&hwctx->internal->cuda_dl);
+        if (ret < 0) {
+            av_log(ctx, AV_LOG_ERROR, "Could not dynamically load CUDA\n");
+            goto error;
+        }
+    }
+
+    return 0;
+
+error:
+    cuda_device_uninit(ctx);
+    return ret;
 }
 
 static int cuda_device_create(AVHWDeviceContext *ctx, const char *device,
                               AVDictionary *opts, int flags)
 {
     AVCUDADeviceContext *hwctx = ctx->hwctx;
+    CudaFunctions *cu;
     CUdevice cu_device;
     CUcontext dummy;
     CUresult err;
@@ -276,29 +316,38 @@ static int cuda_device_create(AVHWDeviceContext *ctx, const char *device,
     if (device)
         device_idx = strtol(device, NULL, 0);
 
-    err = cuInit(0);
+    if (cuda_device_init(ctx) < 0)
+        goto error;
+
+    cu = hwctx->internal->cuda_dl;
+
+    err = cu->cuInit(0);
     if (err != CUDA_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Could not initialize the CUDA driver API\n");
-        return AVERROR_UNKNOWN;
+        goto error;
     }
 
-    err = cuDeviceGet(&cu_device, device_idx);
+    err = cu->cuDeviceGet(&cu_device, device_idx);
     if (err != CUDA_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Could not get the device number %d\n", device_idx);
-        return AVERROR_UNKNOWN;
+        goto error;
     }
 
-    err = cuCtxCreate(&hwctx->cuda_ctx, CU_CTX_SCHED_BLOCKING_SYNC, cu_device);
+    err = cu->cuCtxCreate(&hwctx->cuda_ctx, CU_CTX_SCHED_BLOCKING_SYNC, cu_device);
     if (err != CUDA_SUCCESS) {
         av_log(ctx, AV_LOG_ERROR, "Error creating a CUDA context\n");
-        return AVERROR_UNKNOWN;
+        goto error;
     }
 
-    cuCtxPopCurrent(&dummy);
+    cu->cuCtxPopCurrent(&dummy);
 
-    ctx->free = cuda_device_free;
+    hwctx->internal->is_allocated = 1;
 
     return 0;
+
+error:
+    cuda_device_uninit(ctx);
+    return AVERROR_UNKNOWN;
 }
 
 const HWContextType ff_hwcontext_type_cuda = {
@@ -309,6 +358,8 @@ const HWContextType ff_hwcontext_type_cuda = {
     .frames_priv_size     = sizeof(CUDAFramesContext),
 
     .device_create        = cuda_device_create,
+    .device_init          = cuda_device_init,
+    .device_uninit        = cuda_device_uninit,
     .frames_init          = cuda_frames_init,
     .frames_get_buffer    = cuda_get_buffer,
     .transfer_get_formats = cuda_transfer_get_formats,
diff --git a/libavutil/hwcontext_cuda.h b/libavutil/hwcontext_cuda.h
index 23a77ce..12dae84 100644
--- a/libavutil/hwcontext_cuda.h
+++ b/libavutil/hwcontext_cuda.h
@@ -20,7 +20,9 @@
 #ifndef AVUTIL_HWCONTEXT_CUDA_H
 #define AVUTIL_HWCONTEXT_CUDA_H
 
+#ifndef CUDA_VERSION
 #include <cuda.h>
+#endif
 
 #include "pixfmt.h"
 
@@ -32,11 +34,14 @@
  * AVBufferRefs whose data pointer is a CUdeviceptr.
  */
 
+typedef struct AVCUDADeviceContextInternal AVCUDADeviceContextInternal;
+
 /**
  * This struct is allocated as AVHWDeviceContext.hwctx
  */
 typedef struct AVCUDADeviceContext {
     CUcontext cuda_ctx;
+    AVCUDADeviceContextInternal *internal;
 } AVCUDADeviceContext;
 
 /**
diff --git a/libavutil/hwcontext_cuda_internal.h b/libavutil/hwcontext_cuda_internal.h
new file mode 100644
index 0000000..e1bc6ff
--- /dev/null
+++ b/libavutil/hwcontext_cuda_internal.h
@@ -0,0 +1,37 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+
+#ifndef AVUTIL_HWCONTEXT_CUDA_INTERNAL_H
+#define AVUTIL_HWCONTEXT_CUDA_INTERNAL_H
+
+#include "compat/cuda/dynlink_loader.h"
+#include "hwcontext_cuda.h"
+
+/**
+ * @file
+ * FFmpeg internal API for CUDA.
+ */
+
+struct AVCUDADeviceContextInternal {
+    CudaFunctions *cuda_dl;
+    int is_allocated;
+};
+
+#endif /* AVUTIL_HWCONTEXT_CUDA_INTERNAL_H */
+
-- 
2.10.1


From cdd6492eba7d4674918338e2f5a897bd26fff67f Mon Sep 17 00:00:00 2001
From: Timo Rothenpieler <timo@rothenpieler.org>
Date: Mon, 10 Oct 2016 12:53:49 +0200
Subject: [PATCH 3/8] avcodec/cuvid: use dynamically loaded CUDA/CUVID

And remove the now obsolete compat headers.
---
 compat/cuda/cuviddec.h | 827 -------------------------------------------------
 compat/cuda/nvcuvid.h  | 321 -------------------
 libavcodec/cuvid.c     |  80 +++--
 3 files changed, 48 insertions(+), 1180 deletions(-)
 delete mode 100644 compat/cuda/cuviddec.h
 delete mode 100644 compat/cuda/nvcuvid.h

diff --git a/compat/cuda/cuviddec.h b/compat/cuda/cuviddec.h
deleted file mode 100644
index f9257ea..0000000
--- a/compat/cuda/cuviddec.h
+++ /dev/null
@@ -1,827 +0,0 @@
-/*
- * This copyright notice applies to this header file only:
- *
- * Copyright (c) 2010-2016 NVIDIA Corporation
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use,
- * copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the software, and to permit persons to whom the
- * software is furnished to do so, subject to the following
- * conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file cuviddec.h
- * NvCuvid API provides Video Decoding interface to NVIDIA GPU devices.
- * \date 2015-2016
- * This file contains constants, structure definitions and function prototypes used for decoding.
- */
-
-#if !defined(__CUDA_VIDEO_H__)
-#define __CUDA_VIDEO_H__
-
-#ifndef __cuda_cuda_h__
-#include <cuda.h>
-#endif // __cuda_cuda_h__
-
-#if defined(__x86_64) || defined(AMD64) || defined(_M_AMD64)
-#if (CUDA_VERSION >= 3020) && (!defined(CUDA_FORCE_API_VERSION) || (CUDA_FORCE_API_VERSION >= 3020))
-#define __CUVID_DEVPTR64
-#endif
-#endif
-
-#if defined(__cplusplus)
-extern "C" {
-#endif /* __cplusplus */
-
-typedef void *CUvideodecoder;
-typedef struct _CUcontextlock_st *CUvideoctxlock;
-
-/**
- * \addtogroup VIDEO_DECODER Video Decoder
- * @{
- */
-
-/*!
- * \enum cudaVideoCodec
- * Video Codec Enums
- */
-typedef enum cudaVideoCodec_enum {
-    cudaVideoCodec_MPEG1=0,                 /**<  MPEG1   */
-    cudaVideoCodec_MPEG2,                   /**<  MPEG2  */
-    cudaVideoCodec_MPEG4,                   /**<  MPEG4   */
-    cudaVideoCodec_VC1,                     /**<  VC1   */
-    cudaVideoCodec_H264,                    /**<  H264   */
-    cudaVideoCodec_JPEG,                    /**<  JPEG   */
-    cudaVideoCodec_H264_SVC,                /**<  H264-SVC   */
-    cudaVideoCodec_H264_MVC,                /**<  H264-MVC   */
-    cudaVideoCodec_HEVC,                    /**<  HEVC   */
-    cudaVideoCodec_VP8,                     /**<  VP8   */
-    cudaVideoCodec_VP9,                     /**<  VP9   */
-    cudaVideoCodec_NumCodecs,               /**<  Max COdecs   */
-    // Uncompressed YUV
-    cudaVideoCodec_YUV420 = (('I'<<24)|('Y'<<16)|('U'<<8)|('V')),   /**< Y,U,V (4:2:0)  */
-    cudaVideoCodec_YV12   = (('Y'<<24)|('V'<<16)|('1'<<8)|('2')),   /**< Y,V,U (4:2:0)  */
-    cudaVideoCodec_NV12   = (('N'<<24)|('V'<<16)|('1'<<8)|('2')),   /**< Y,UV  (4:2:0)  */
-    cudaVideoCodec_YUYV   = (('Y'<<24)|('U'<<16)|('Y'<<8)|('V')),   /**< YUYV/YUY2 (4:2:2)  */
-    cudaVideoCodec_UYVY   = (('U'<<24)|('Y'<<16)|('V'<<8)|('Y'))    /**< UYVY (4:2:2)  */
-} cudaVideoCodec;
-
-/*!
- * \enum cudaVideoSurfaceFormat
- * Video Surface Formats Enums
- */
-typedef enum cudaVideoSurfaceFormat_enum {
-    cudaVideoSurfaceFormat_NV12=0       /**< NV12 (currently the only supported output format)  */
-} cudaVideoSurfaceFormat;
-
-/*!
- * \enum cudaVideoDeinterlaceMode
- * Deinterlacing Modes Enums
- */
-typedef enum cudaVideoDeinterlaceMode_enum {
-    cudaVideoDeinterlaceMode_Weave=0,   /**< Weave both fields (no deinterlacing) */
-    cudaVideoDeinterlaceMode_Bob,       /**< Drop one field  */
-    cudaVideoDeinterlaceMode_Adaptive   /**< Adaptive deinterlacing  */
-} cudaVideoDeinterlaceMode;
-
-/*!
- * \enum cudaVideoChromaFormat
- * Chroma Formats Enums
- */
-typedef enum cudaVideoChromaFormat_enum {
-    cudaVideoChromaFormat_Monochrome=0,  /**< MonoChrome */
-    cudaVideoChromaFormat_420,           /**< 4:2:0 */
-    cudaVideoChromaFormat_422,           /**< 4:2:2 */
-    cudaVideoChromaFormat_444            /**< 4:4:4 */
-} cudaVideoChromaFormat;
-
-/*!
- * \enum cudaVideoCreateFlags
- * Decoder Flags Enums
- */
-typedef enum cudaVideoCreateFlags_enum {
-    cudaVideoCreate_Default = 0x00,     /**< Default operation mode: use dedicated video engines */
-    cudaVideoCreate_PreferCUDA = 0x01,  /**< Use a CUDA-based decoder if faster than dedicated engines (requires a valid vidLock object for multi-threading) */
-    cudaVideoCreate_PreferDXVA = 0x02,  /**< Go through DXVA internally if possible (requires D3D9 interop) */
-    cudaVideoCreate_PreferCUVID = 0x04  /**< Use dedicated video engines directly */
-} cudaVideoCreateFlags;
-
-/*!
- * \struct CUVIDDECODECREATEINFO
- * Struct used in create decoder
- */
-typedef struct _CUVIDDECODECREATEINFO
-{
-    unsigned long ulWidth;              /**< Coded Sequence Width */
-    unsigned long ulHeight;             /**< Coded Sequence Height */
-    unsigned long ulNumDecodeSurfaces;  /**< Maximum number of internal decode surfaces */
-    cudaVideoCodec CodecType;           /**< cudaVideoCodec_XXX */
-    cudaVideoChromaFormat ChromaFormat; /**< cudaVideoChromaFormat_XXX (only 4:2:0 is currently supported) */
-    unsigned long ulCreationFlags;      /**< Decoder creation flags (cudaVideoCreateFlags_XXX) */
-    unsigned long bitDepthMinus8;
-    unsigned long Reserved1[4];         /**< Reserved for future use - set to zero */
-    /**
-    * area of the frame that should be displayed
-    */
-    struct {
-        short left;
-        short top;
-        short right;
-        short bottom;
-    } display_area;
-
-    cudaVideoSurfaceFormat OutputFormat;       /**< cudaVideoSurfaceFormat_XXX */
-    cudaVideoDeinterlaceMode DeinterlaceMode;  /**< cudaVideoDeinterlaceMode_XXX */
-    unsigned long ulTargetWidth;               /**< Post-processed Output Width (Should be aligned to 2) */
-    unsigned long ulTargetHeight;              /**< Post-processed Output Height (Should be aligbed to 2) */
-    unsigned long ulNumOutputSurfaces;         /**< Maximum number of output surfaces simultaneously mapped */
-    CUvideoctxlock vidLock;                    /**< If non-NULL, context lock used for synchronizing ownership of the cuda context */
-    /**
-    * target rectangle in the output frame (for aspect ratio conversion)
-    * if a null rectangle is specified, {0,0,ulTargetWidth,ulTargetHeight} will be used
-    */
-    struct {
-        short left;
-        short top;
-        short right;
-        short bottom;
-    } target_rect;
-    unsigned long Reserved2[5];                /**< Reserved for future use - set to zero */
-} CUVIDDECODECREATEINFO;
-
-/*!
- * \struct CUVIDH264DPBENTRY
- * H.264 DPB Entry
- */
-typedef struct _CUVIDH264DPBENTRY
-{
-    int PicIdx;                 /**< picture index of reference frame */
-    int FrameIdx;               /**< frame_num(short-term) or LongTermFrameIdx(long-term) */
-    int is_long_term;           /**< 0=short term reference, 1=long term reference */
-    int not_existing;           /**< non-existing reference frame (corresponding PicIdx should be set to -1) */
-    int used_for_reference;     /**< 0=unused, 1=top_field, 2=bottom_field, 3=both_fields */
-    int FieldOrderCnt[2];       /**< field order count of top and bottom fields */
-} CUVIDH264DPBENTRY;
-
-/*!
- * \struct CUVIDH264MVCEXT
- * H.264 MVC Picture Parameters Ext
- */
-typedef struct _CUVIDH264MVCEXT
-{
-    int num_views_minus1;
-    int view_id;
-    unsigned char inter_view_flag;
-    unsigned char num_inter_view_refs_l0;
-    unsigned char num_inter_view_refs_l1;
-    unsigned char MVCReserved8Bits;
-    int InterViewRefsL0[16];
-    int InterViewRefsL1[16];
-} CUVIDH264MVCEXT;
-
-/*!
- * \struct CUVIDH264SVCEXT
- * H.264 SVC Picture Parameters Ext
- */
-typedef struct _CUVIDH264SVCEXT
-{
-    unsigned char profile_idc;
-    unsigned char level_idc;
-    unsigned char DQId;
-    unsigned char DQIdMax;
-    unsigned char disable_inter_layer_deblocking_filter_idc;
-    unsigned char ref_layer_chroma_phase_y_plus1;
-    signed char   inter_layer_slice_alpha_c0_offset_div2;
-    signed char   inter_layer_slice_beta_offset_div2;
-
-    unsigned short DPBEntryValidFlag;
-    unsigned char inter_layer_deblocking_filter_control_present_flag;
-    unsigned char extended_spatial_scalability_idc;
-    unsigned char adaptive_tcoeff_level_prediction_flag;
-    unsigned char slice_header_restriction_flag;
-    unsigned char chroma_phase_x_plus1_flag;
-    unsigned char chroma_phase_y_plus1;
-
-    unsigned char tcoeff_level_prediction_flag;
-    unsigned char constrained_intra_resampling_flag;
-    unsigned char ref_layer_chroma_phase_x_plus1_flag;
-    unsigned char store_ref_base_pic_flag;
-    unsigned char Reserved8BitsA;
-    unsigned char Reserved8BitsB;
-    // For the 4 scaled_ref_layer_XX fields below,
-    // if (extended_spatial_scalability_idc == 1), SPS field, G.7.3.2.1.4, add prefix "seq_"
-    // if (extended_spatial_scalability_idc == 2), SLH field, G.7.3.3.4,
-    short scaled_ref_layer_left_offset;
-    short scaled_ref_layer_top_offset;
-    short scaled_ref_layer_right_offset;
-    short scaled_ref_layer_bottom_offset;
-    unsigned short Reserved16Bits;
-    struct _CUVIDPICPARAMS *pNextLayer; /**< Points to the picparams for the next layer to be decoded. Linked list ends at the target layer. */
-    int bRefBaseLayer;                  /**< whether to store ref base pic */
-} CUVIDH264SVCEXT;
-
-/*!
- * \struct CUVIDH264PICPARAMS
- * H.264 Picture Parameters
- */
-typedef struct _CUVIDH264PICPARAMS
-{
-    // SPS
-    int log2_max_frame_num_minus4;
-    int pic_order_cnt_type;
-    int log2_max_pic_order_cnt_lsb_minus4;
-    int delta_pic_order_always_zero_flag;
-    int frame_mbs_only_flag;
-    int direct_8x8_inference_flag;
-    int num_ref_frames;             // NOTE: shall meet level 4.1 restrictions
-    unsigned char residual_colour_transform_flag;
-    unsigned char bit_depth_luma_minus8;    // Must be 0 (only 8-bit supported)
-    unsigned char bit_depth_chroma_minus8;  // Must be 0 (only 8-bit supported)
-    unsigned char qpprime_y_zero_transform_bypass_flag;
-    // PPS
-    int entropy_coding_mode_flag;
-    int pic_order_present_flag;
-    int num_ref_idx_l0_active_minus1;
-    int num_ref_idx_l1_active_minus1;
-    int weighted_pred_flag;
-    int weighted_bipred_idc;
-    int pic_init_qp_minus26;
-    int deblocking_filter_control_present_flag;
-    int redundant_pic_cnt_present_flag;
-    int transform_8x8_mode_flag;
-    int MbaffFrameFlag;
-    int constrained_intra_pred_flag;
-    int chroma_qp_index_offset;
-    int second_chroma_qp_index_offset;
-    int ref_pic_flag;
-    int frame_num;
-    int CurrFieldOrderCnt[2];
-    // DPB
-    CUVIDH264DPBENTRY dpb[16];          // List of reference frames within the DPB
-    // Quantization Matrices (raster-order)
-    unsigned char WeightScale4x4[6][16];
-    unsigned char WeightScale8x8[2][64];
-    // FMO/ASO
-    unsigned char fmo_aso_enable;
-    unsigned char num_slice_groups_minus1;
-    unsigned char slice_group_map_type;
-    signed char pic_init_qs_minus26;
-    unsigned int slice_group_change_rate_minus1;
-    union
-    {
-        unsigned long long slice_group_map_addr;
-        const unsigned char *pMb2SliceGroupMap;
-    } fmo;
-    unsigned int  Reserved[12];
-    // SVC/MVC
-    union
-    {
-        CUVIDH264MVCEXT mvcext;
-        CUVIDH264SVCEXT svcext;
-    };
-} CUVIDH264PICPARAMS;
-
-
-/*!
- * \struct CUVIDMPEG2PICPARAMS
- * MPEG-2 Picture Parameters
- */
-typedef struct _CUVIDMPEG2PICPARAMS
-{
-    int ForwardRefIdx;          // Picture index of forward reference (P/B-frames)
-    int BackwardRefIdx;         // Picture index of backward reference (B-frames)
-    int picture_coding_type;
-    int full_pel_forward_vector;
-    int full_pel_backward_vector;
-    int f_code[2][2];
-    int intra_dc_precision;
-    int frame_pred_frame_dct;
-    int concealment_motion_vectors;
-    int q_scale_type;
-    int intra_vlc_format;
-    int alternate_scan;
-    int top_field_first;
-    // Quantization matrices (raster order)
-    unsigned char QuantMatrixIntra[64];
-    unsigned char QuantMatrixInter[64];
-} CUVIDMPEG2PICPARAMS;
-
-////////////////////////////////////////////////////////////////////////////////////////////////
-//
-// MPEG-4 Picture Parameters
-//
-
-// MPEG-4 has VOP types instead of Picture types
-#define I_VOP 0
-#define P_VOP 1
-#define B_VOP 2
-#define S_VOP 3
-
-/*!
- * \struct CUVIDMPEG4PICPARAMS
- * MPEG-4 Picture Parameters
- */
-typedef struct _CUVIDMPEG4PICPARAMS
-{
-    int ForwardRefIdx;          // Picture index of forward reference (P/B-frames)
-    int BackwardRefIdx;         // Picture index of backward reference (B-frames)
-    // VOL
-    int video_object_layer_width;
-    int video_object_layer_height;
-    int vop_time_increment_bitcount;
-    int top_field_first;
-    int resync_marker_disable;
-    int quant_type;
-    int quarter_sample;
-    int short_video_header;
-    int divx_flags;
-    // VOP
-    int vop_coding_type;
-    int vop_coded;
-    int vop_rounding_type;
-    int alternate_vertical_scan_flag;
-    int interlaced;
-    int vop_fcode_forward;
-    int vop_fcode_backward;
-    int trd[2];
-    int trb[2];
-    // Quantization matrices (raster order)
-    unsigned char QuantMatrixIntra[64];
-    unsigned char QuantMatrixInter[64];
-    int gmc_enabled;
-} CUVIDMPEG4PICPARAMS;
-
-/*!
- * \struct CUVIDVC1PICPARAMS
- * VC1 Picture Parameters
- */
-typedef struct _CUVIDVC1PICPARAMS
-{
-    int ForwardRefIdx;      /**< Picture index of forward reference (P/B-frames) */
-    int BackwardRefIdx;     /**< Picture index of backward reference (B-frames) */
-    int FrameWidth;         /**< Actual frame width */
-    int FrameHeight;        /**< Actual frame height */
-    // PICTURE
-    int intra_pic_flag;     /**< Set to 1 for I,BI frames */
-    int ref_pic_flag;       /**< Set to 1 for I,P frames */
-    int progressive_fcm;    /**< Progressive frame */
-    // SEQUENCE
-    int profile;
-    int postprocflag;
-    int pulldown;
-    int interlace;
-    int tfcntrflag;
-    int finterpflag;
-    int psf;
-    int multires;
-    int syncmarker;
-    int rangered;
-    int maxbframes;
-    // ENTRYPOINT
-    int panscan_flag;
-    int refdist_flag;
-    int extended_mv;
-    int dquant;
-    int vstransform;
-    int loopfilter;
-    int fastuvmc;
-    int overlap;
-    int quantizer;
-    int extended_dmv;
-    int range_mapy_flag;
-    int range_mapy;
-    int range_mapuv_flag;
-    int range_mapuv;
-    int rangeredfrm;    // range reduction state
-} CUVIDVC1PICPARAMS;
-
-/*!
- * \struct CUVIDJPEGPICPARAMS
- * JPEG Picture Parameters
- */
-typedef struct _CUVIDJPEGPICPARAMS
-{
-    int Reserved;
-} CUVIDJPEGPICPARAMS;
-
-
- /*!
- * \struct CUVIDHEVCPICPARAMS
- * HEVC Picture Parameters
- */
-typedef struct _CUVIDHEVCPICPARAMS
-{
-    // sps
-    int pic_width_in_luma_samples;
-    int pic_height_in_luma_samples;
-    unsigned char log2_min_luma_coding_block_size_minus3;
-    unsigned char log2_diff_max_min_luma_coding_block_size;
-    unsigned char log2_min_transform_block_size_minus2;
-    unsigned char log2_diff_max_min_transform_block_size;
-    unsigned char pcm_enabled_flag;
-    unsigned char log2_min_pcm_luma_coding_block_size_minus3;
-    unsigned char log2_diff_max_min_pcm_luma_coding_block_size;
-    unsigned char pcm_sample_bit_depth_luma_minus1;
-
-    unsigned char pcm_sample_bit_depth_chroma_minus1;
-    unsigned char pcm_loop_filter_disabled_flag;
-    unsigned char strong_intra_smoothing_enabled_flag;
-    unsigned char max_transform_hierarchy_depth_intra;
-    unsigned char max_transform_hierarchy_depth_inter;
-    unsigned char amp_enabled_flag;
-    unsigned char separate_colour_plane_flag;
-    unsigned char log2_max_pic_order_cnt_lsb_minus4;
-
-    unsigned char num_short_term_ref_pic_sets;
-    unsigned char long_term_ref_pics_present_flag;
-    unsigned char num_long_term_ref_pics_sps;
-    unsigned char sps_temporal_mvp_enabled_flag;
-    unsigned char sample_adaptive_offset_enabled_flag;
-    unsigned char scaling_list_enable_flag;
-    unsigned char IrapPicFlag;
-    unsigned char IdrPicFlag;
-
-    unsigned char bit_depth_luma_minus8;
-    unsigned char bit_depth_chroma_minus8;
-    unsigned char reserved1[14];
-
-    // pps
-    unsigned char dependent_slice_segments_enabled_flag;
-    unsigned char slice_segment_header_extension_present_flag;
-    unsigned char sign_data_hiding_enabled_flag;
-    unsigned char cu_qp_delta_enabled_flag;
-    unsigned char diff_cu_qp_delta_depth;
-    signed char init_qp_minus26;
-    signed char pps_cb_qp_offset;
-    signed char pps_cr_qp_offset;
-
-    unsigned char constrained_intra_pred_flag;
-    unsigned char weighted_pred_flag;
-    unsigned char weighted_bipred_flag;
-    unsigned char transform_skip_enabled_flag;
-    unsigned char transquant_bypass_enabled_flag;
-    unsigned char entropy_coding_sync_enabled_flag;
-    unsigned char log2_parallel_merge_level_minus2;
-    unsigned char num_extra_slice_header_bits;
-
-    unsigned char loop_filter_across_tiles_enabled_flag;
-    unsigned char loop_filter_across_slices_enabled_flag;
-    unsigned char output_flag_present_flag;
-    unsigned char num_ref_idx_l0_default_active_minus1;
-    unsigned char num_ref_idx_l1_default_active_minus1;
-    unsigned char lists_modification_present_flag;
-    unsigned char cabac_init_present_flag;
-    unsigned char pps_slice_chroma_qp_offsets_present_flag;
-
-    unsigned char deblocking_filter_override_enabled_flag;
-    unsigned char pps_deblocking_filter_disabled_flag;
-    signed char pps_beta_offset_div2;
-    signed char pps_tc_offset_div2;
-    unsigned char tiles_enabled_flag;
-    unsigned char uniform_spacing_flag;
-    unsigned char num_tile_columns_minus1;
-    unsigned char num_tile_rows_minus1;
-
-    unsigned short column_width_minus1[21];
-    unsigned short row_height_minus1[21];
-    unsigned int reserved3[15];
-
-    // RefPicSets
-    int NumBitsForShortTermRPSInSlice;
-    int NumDeltaPocsOfRefRpsIdx;
-    int NumPocTotalCurr;
-    int NumPocStCurrBefore;
-    int NumPocStCurrAfter;
-    int NumPocLtCurr;
-    int CurrPicOrderCntVal;
-    int RefPicIdx[16];                  // [refpic] Indices of valid reference pictures (-1 if unused for reference)
-    int PicOrderCntVal[16];             // [refpic]
-    unsigned char IsLongTerm[16];       // [refpic] 0=not a long-term reference, 1=long-term reference
-    unsigned char RefPicSetStCurrBefore[8]; // [0..NumPocStCurrBefore-1] -> refpic (0..15)
-    unsigned char RefPicSetStCurrAfter[8];  // [0..NumPocStCurrAfter-1] -> refpic (0..15)
-    unsigned char RefPicSetLtCurr[8];       // [0..NumPocLtCurr-1] -> refpic (0..15)
-    unsigned char RefPicSetInterLayer0[8];
-    unsigned char RefPicSetInterLayer1[8];
-    unsigned int reserved4[12];
-
-    // scaling lists (diag order)
-    unsigned char ScalingList4x4[6][16];       // [matrixId][i]
-    unsigned char ScalingList8x8[6][64];       // [matrixId][i]
-    unsigned char ScalingList16x16[6][64];     // [matrixId][i]
-    unsigned char ScalingList32x32[2][64];     // [matrixId][i]
-    unsigned char ScalingListDCCoeff16x16[6];  // [matrixId]
-    unsigned char ScalingListDCCoeff32x32[2];  // [matrixId]
-} CUVIDHEVCPICPARAMS;
-
-
-/*!
- * \struct CUVIDVP8PICPARAMS
- * VP8 Picture Parameters
- */
-typedef struct _CUVIDVP8PICPARAMS
-{
-    int width;
-    int height;
-    unsigned int first_partition_size;
-    //Frame Indexes
-    unsigned char LastRefIdx;
-    unsigned char GoldenRefIdx;
-    unsigned char AltRefIdx;
-    union {
-        struct {
-            unsigned char frame_type : 1;    /**< 0 = KEYFRAME, 1 = INTERFRAME  */
-            unsigned char version : 3;
-            unsigned char show_frame : 1;
-            unsigned char update_mb_segmentation_data : 1;    /**< Must be 0 if segmentation is not enabled */
-            unsigned char Reserved2Bits : 2;
-        };
-        unsigned char wFrameTagFlags;
-    };
-    unsigned char Reserved1[4];
-    unsigned int  Reserved2[3];
-} CUVIDVP8PICPARAMS;
-
-/*!
- * \struct CUVIDVP9PICPARAMS
- * VP9 Picture Parameters
- */
-typedef struct _CUVIDVP9PICPARAMS
-{
-    unsigned int width;
-    unsigned int height;
-
-    //Frame Indices
-    unsigned char LastRefIdx;
-    unsigned char GoldenRefIdx;
-    unsigned char AltRefIdx;
-    unsigned char colorSpace;
-
-    unsigned short profile : 3;
-    unsigned short frameContextIdx : 2;
-    unsigned short frameType : 1;
-    unsigned short showFrame : 1;
-    unsigned short errorResilient : 1;
-    unsigned short frameParallelDecoding : 1;
-    unsigned short subSamplingX : 1;
-    unsigned short subSamplingY : 1;
-    unsigned short intraOnly : 1;
-    unsigned short allow_high_precision_mv : 1;
-    unsigned short refreshEntropyProbs : 1;
-    unsigned short reserved2Bits : 2;
-
-    unsigned short reserved16Bits;
-
-    unsigned char  refFrameSignBias[4];
-
-    unsigned char bitDepthMinus8Luma;
-    unsigned char bitDepthMinus8Chroma;
-    unsigned char loopFilterLevel;
-    unsigned char loopFilterSharpness;
-
-    unsigned char modeRefLfEnabled;
-    unsigned char log2_tile_columns;
-    unsigned char log2_tile_rows;
-
-    unsigned char segmentEnabled : 1;
-    unsigned char segmentMapUpdate : 1;
-    unsigned char segmentMapTemporalUpdate : 1;
-    unsigned char segmentFeatureMode : 1;
-    unsigned char reserved4Bits : 4;
-
-
-    unsigned char segmentFeatureEnable[8][4];
-    short segmentFeatureData[8][4];
-    unsigned char mb_segment_tree_probs[7];
-    unsigned char segment_pred_probs[3];
-    unsigned char reservedSegment16Bits[2];
-
-    int qpYAc;
-    int qpYDc;
-    int qpChDc;
-    int qpChAc;
-
-    unsigned int activeRefIdx[3];
-    unsigned int resetFrameContext;
-    unsigned int mcomp_filter_type;
-    unsigned int mbRefLfDelta[4];
-    unsigned int mbModeLfDelta[2];
-    unsigned int frameTagSize;
-    unsigned int offsetToDctParts;
-    unsigned int reserved128Bits[4];
-
-} CUVIDVP9PICPARAMS;
-
-
-/*!
- * \struct CUVIDPICPARAMS
- * Picture Parameters for Decoding
- */
-typedef struct _CUVIDPICPARAMS
-{
-    int PicWidthInMbs;                    /**< Coded Frame Size */
-    int FrameHeightInMbs;                 /**< Coded Frame Height */
-    int CurrPicIdx;                       /**< Output index of the current picture */
-    int field_pic_flag;                   /**< 0=frame picture, 1=field picture */
-    int bottom_field_flag;                /**< 0=top field, 1=bottom field (ignored if field_pic_flag=0) */
-    int second_field;                     /**< Second field of a complementary field pair */
-    // Bitstream data
-    unsigned int nBitstreamDataLen;        /**< Number of bytes in bitstream data buffer */
-    const unsigned char *pBitstreamData;   /**< Ptr to bitstream data for this picture (slice-layer) */
-    unsigned int nNumSlices;               /**< Number of slices in this picture */
-    const unsigned int *pSliceDataOffsets; /**< nNumSlices entries, contains offset of each slice within the bitstream data buffer */
-    int ref_pic_flag;                      /**< This picture is a reference picture */
-    int intra_pic_flag;                    /**< This picture is entirely intra coded */
-    unsigned int Reserved[30];             /**< Reserved for future use */
-    // Codec-specific data
-    union {
-        CUVIDMPEG2PICPARAMS mpeg2;         /**< Also used for MPEG-1 */
-        CUVIDH264PICPARAMS h264;
-        CUVIDVC1PICPARAMS vc1;
-        CUVIDMPEG4PICPARAMS mpeg4;
-        CUVIDJPEGPICPARAMS jpeg;
-        CUVIDHEVCPICPARAMS hevc;
-        CUVIDVP8PICPARAMS vp8;
-        CUVIDVP9PICPARAMS vp9;
-        unsigned int CodecReserved[1024];
-    } CodecSpecific;
-} CUVIDPICPARAMS;
-
-
-/*!
- * \struct CUVIDPROCPARAMS
- * Picture Parameters for Postprocessing
- */
-typedef struct _CUVIDPROCPARAMS
-{
-    int progressive_frame;  /**< Input is progressive (deinterlace_mode will be ignored)  */
-    int second_field;       /**< Output the second field (ignored if deinterlace mode is Weave) */
-    int top_field_first;    /**< Input frame is top field first (1st field is top, 2nd field is bottom) */
-    int unpaired_field;     /**< Input only contains one field (2nd field is invalid) */
-    // The fields below are used for raw YUV input
-    unsigned int reserved_flags;        /**< Reserved for future use (set to zero) */
-    unsigned int reserved_zero;         /**< Reserved (set to zero) */
-    unsigned long long raw_input_dptr;  /**< Input CUdeviceptr for raw YUV extensions */
-    unsigned int raw_input_pitch;       /**< pitch in bytes of raw YUV input (should be aligned appropriately) */
-    unsigned int raw_input_format;      /**< Reserved for future use (set to zero) */
-    unsigned long long raw_output_dptr; /**< Reserved for future use (set to zero) */
-    unsigned int raw_output_pitch;      /**< Reserved for future use (set to zero) */
-    unsigned int Reserved[48];
-    void *Reserved3[3];
-} CUVIDPROCPARAMS;
-
-
-/**
- *
- * In order to minimize decode latencies, there should be always at least 2 pictures in the decode
- * queue at any time, in order to make sure that all decode engines are always busy.
- *
- * Overall data flow:
- *  - cuvidCreateDecoder(...)
- *  For each picture:
- *  - cuvidDecodePicture(N)
- *  - cuvidMapVideoFrame(N-4)
- *  - do some processing in cuda
- *  - cuvidUnmapVideoFrame(N-4)
- *  - cuvidDecodePicture(N+1)
- *  - cuvidMapVideoFrame(N-3)
- *    ...
- *  - cuvidDestroyDecoder(...)
- *
- * NOTE:
- * - When the cuda context is created from a D3D device, the D3D device must also be created
- *   with the D3DCREATE_MULTITHREADED flag.
- * - There is a limit to how many pictures can be mapped simultaneously (ulNumOutputSurfaces)
- * - cuVidDecodePicture may block the calling thread if there are too many pictures pending
- *   in the decode queue
- */
-
-/**
- * \fn CUresult CUDAAPI cuvidCreateDecoder(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci)
- * Create the decoder object
- */
-CUresult CUDAAPI cuvidCreateDecoder(CUvideodecoder *phDecoder, CUVIDDECODECREATEINFO *pdci);
-
-/**
- * \fn CUresult CUDAAPI cuvidDestroyDecoder(CUvideodecoder hDecoder)
- * Destroy the decoder object
- */
-CUresult CUDAAPI cuvidDestroyDecoder(CUvideodecoder hDecoder);
-
-/**
- * \fn CUresult CUDAAPI cuvidDecodePicture(CUvideodecoder hDecoder, CUVIDPICPARAMS *pPicParams)
- * Decode a single picture (field or frame)
- */
-CUresult CUDAAPI cuvidDecodePicture(CUvideodecoder hDecoder, CUVIDPICPARAMS *pPicParams);
-
-
-#if !defined(__CUVID_DEVPTR64) || defined(__CUVID_INTERNAL)
-/**
- * \fn CUresult CUDAAPI cuvidMapVideoFrame(CUvideodecoder hDecoder, int nPicIdx, unsigned int *pDevPtr, unsigned int *pPitch, CUVIDPROCPARAMS *pVPP);
- * Post-process and map a video frame for use in cuda
- */
-CUresult CUDAAPI cuvidMapVideoFrame(CUvideodecoder hDecoder, int nPicIdx,
-                                           unsigned int *pDevPtr, unsigned int *pPitch,
-                                           CUVIDPROCPARAMS *pVPP);
-
-/**
- * \fn CUresult CUDAAPI cuvidUnmapVideoFrame(CUvideodecoder hDecoder, unsigned int DevPtr)
- * Unmap a previously mapped video frame
- */
-CUresult CUDAAPI cuvidUnmapVideoFrame(CUvideodecoder hDecoder, unsigned int DevPtr);
-#endif
-
-#if defined(WIN64) || defined(_WIN64) || defined(__x86_64) || defined(AMD64) || defined(_M_AMD64)
-/**
- * \fn CUresult CUDAAPI cuvidMapVideoFrame64(CUvideodecoder hDecoder, int nPicIdx, unsigned long long *pDevPtr, unsigned int *pPitch, CUVIDPROCPARAMS *pVPP);
- * map a video frame
- */
-CUresult CUDAAPI cuvidMapVideoFrame64(CUvideodecoder hDecoder, int nPicIdx, unsigned long long *pDevPtr,
-                                             unsigned int *pPitch, CUVIDPROCPARAMS *pVPP);
-
-/**
- * \fn CUresult CUDAAPI cuvidUnmapVideoFrame64(CUvideodecoder hDecoder, unsigned long long DevPtr);
- * Unmap a previously mapped video frame
- */
-CUresult CUDAAPI cuvidUnmapVideoFrame64(CUvideodecoder hDecoder, unsigned long long DevPtr);
-
-#if defined(__CUVID_DEVPTR64) && !defined(__CUVID_INTERNAL)
-#define cuvidMapVideoFrame      cuvidMapVideoFrame64
-#define cuvidUnmapVideoFrame    cuvidUnmapVideoFrame64
-#endif
-#endif
-
-
-
-/**
- *
- * Context-locking: to facilitate multi-threaded implementations, the following 4 functions
- * provide a simple mutex-style host synchronization. If a non-NULL context is specified
- * in CUVIDDECODECREATEINFO, the codec library will acquire the mutex associated with the given
- * context before making any cuda calls.
- * A multi-threaded application could create a lock associated with a context handle so that
- * multiple threads can safely share the same cuda context:
- *  - use cuCtxPopCurrent immediately after context creation in order to create a 'floating' context
- *    that can be passed to cuvidCtxLockCreate.
- *  - When using a floating context, all cuda calls should only be made within a cuvidCtxLock/cuvidCtxUnlock section.
- *
- * NOTE: This is a safer alternative to cuCtxPushCurrent and cuCtxPopCurrent, and is not related to video
- * decoder in any way (implemented as a critical section associated with cuCtx{Push|Pop}Current calls).
-*/
-
-/**
- * \fn CUresult CUDAAPI cuvidCtxLockCreate(CUvideoctxlock *pLock, CUcontext ctx)
- */
-CUresult CUDAAPI cuvidCtxLockCreate(CUvideoctxlock *pLock, CUcontext ctx);
-
-/**
- * \fn CUresult CUDAAPI cuvidCtxLockDestroy(CUvideoctxlock lck)
- */
-CUresult CUDAAPI cuvidCtxLockDestroy(CUvideoctxlock lck);
-
-/**
- * \fn CUresult CUDAAPI cuvidCtxLock(CUvideoctxlock lck, unsigned int reserved_flags)
- */
-CUresult CUDAAPI cuvidCtxLock(CUvideoctxlock lck, unsigned int reserved_flags);
-
-/**
- * \fn CUresult CUDAAPI cuvidCtxUnlock(CUvideoctxlock lck, unsigned int reserved_flags)
- */
-CUresult CUDAAPI cuvidCtxUnlock(CUvideoctxlock lck, unsigned int reserved_flags);
-
-/** @} */  /* End VIDEO_DECODER */
-////////////////////////////////////////////////////////////////////////////////////////////////
-
-#if defined(__cplusplus)
-
-// Auto-lock helper for C++ applications
-class CCtxAutoLock
-{
-private:
-    CUvideoctxlock m_ctx;
-public:
-    CCtxAutoLock(CUvideoctxlock ctx);
-    ~CCtxAutoLock();
-};
-
-}
-
-#endif /* __cplusplus */
-
-#endif // __CUDA_VIDEO_H__
-
diff --git a/compat/cuda/nvcuvid.h b/compat/cuda/nvcuvid.h
deleted file mode 100644
index 738d8e3..0000000
--- a/compat/cuda/nvcuvid.h
+++ /dev/null
@@ -1,321 +0,0 @@
-/*
- * This copyright notice applies to this header file only:
- *
- * Copyright (c) 2010-2016 NVIDIA Corporation
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use,
- * copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the software, and to permit persons to whom the
- * software is furnished to do so, subject to the following
- * conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
- * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
- * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file nvcuvid.h
- *   NvCuvid API provides Video Decoding interface to NVIDIA GPU devices.
- * \date 2015-2015
- *  This file contains the interface constants, structure definitions and function prototypes.
- */
-
-#if !defined(__NVCUVID_H__)
-#define __NVCUVID_H__
-
-#include "compat/cuda/cuviddec.h"
-
-#if defined(__cplusplus)
-extern "C" {
-#endif /* __cplusplus */
-
-/*********************************
-** Initialization
-*********************************/
-CUresult  CUDAAPI cuvidInit(unsigned int Flags);
-
-////////////////////////////////////////////////////////////////////////////////////////////////
-//
-// High-level helper APIs for video sources
-//
-
-typedef void *CUvideosource;
-typedef void *CUvideoparser;
-typedef long long CUvideotimestamp;
-
-/**
- * \addtogroup VIDEO_PARSER Video Parser
- * @{
- */
-
-/*!
- * \enum cudaVideoState
- * Video Source State
- */
-typedef enum {
-    cudaVideoState_Error   = -1,    /**< Error state (invalid source)  */
-    cudaVideoState_Stopped = 0,     /**< Source is stopped (or reached end-of-stream)  */
-    cudaVideoState_Started = 1      /**< Source is running and delivering data  */
-} cudaVideoState;
-
-/*!
- * \enum cudaAudioCodec
- * Audio compression
- */
-typedef enum {
-    cudaAudioCodec_MPEG1=0,         /**< MPEG-1 Audio  */
-    cudaAudioCodec_MPEG2,           /**< MPEG-2 Audio  */
-    cudaAudioCodec_MP3,             /**< MPEG-1 Layer III Audio  */
-    cudaAudioCodec_AC3,             /**< Dolby Digital (AC3) Audio  */
-    cudaAudioCodec_LPCM             /**< PCM Audio  */
-} cudaAudioCodec;
-
-/*!
- * \struct CUVIDEOFORMAT
- * Video format
- */
-typedef struct
-{
-    cudaVideoCodec codec;                   /**< Compression format  */
-   /**
-    * frame rate = numerator / denominator (for example: 30000/1001)
-    */
-    struct {
-        unsigned int numerator;             /**< frame rate numerator   (0 = unspecified or variable frame rate) */
-        unsigned int denominator;           /**< frame rate denominator (0 = unspecified or variable frame rate) */
-    } frame_rate;
-    unsigned char progressive_sequence;     /**< 0=interlaced, 1=progressive */
-    unsigned char bit_depth_luma_minus8;    /**< high bit depth Luma */
-    unsigned char bit_depth_chroma_minus8;  /**< high bit depth Chroma */
-    unsigned char reserved1;                /**< Reserved for future use */
-    unsigned int coded_width;               /**< coded frame width */
-    unsigned int coded_height;              /**< coded frame height  */
-   /**
-    *   area of the frame that should be displayed
-    * typical example:
-    *   coded_width = 1920, coded_height = 1088
-    *   display_area = { 0,0,1920,1080 }
-    */
-    struct {
-        int left;                           /**< left position of display rect  */
-        int top;                            /**< top position of display rect  */
-        int right;                          /**< right position of display rect  */
-        int bottom;                         /**< bottom position of display rect  */
-    } display_area;
-    cudaVideoChromaFormat chroma_format;    /**<  Chroma format */
-    unsigned int bitrate;                   /**< video bitrate (bps, 0=unknown) */
-   /**
-    * Display Aspect Ratio = x:y (4:3, 16:9, etc)
-    */
-    struct {
-        int x;
-        int y;
-    } display_aspect_ratio;
-    /**
-    * Video Signal Description
-    */
-    struct {
-        unsigned char video_format          : 3;
-        unsigned char video_full_range_flag : 1;
-        unsigned char reserved_zero_bits    : 4;
-        unsigned char color_primaries;
-        unsigned char transfer_characteristics;
-        unsigned char matrix_coefficients;
-    } video_signal_description;
-    unsigned int seqhdr_data_length;          /**< Additional bytes following (CUVIDEOFORMATEX)  */
-} CUVIDEOFORMAT;
-
-/*!
- * \struct CUVIDEOFORMATEX
- * Video format including raw sequence header information
- */
-typedef struct
-{
-    CUVIDEOFORMAT format;
-    unsigned char raw_seqhdr_data[1024];
-} CUVIDEOFORMATEX;
-
-/*!
- * \struct CUAUDIOFORMAT
- * Audio Formats
- */
-typedef struct
-{
-    cudaAudioCodec codec;       /**< Compression format  */
-    unsigned int channels;      /**< number of audio channels */
-    unsigned int samplespersec; /**< sampling frequency */
-    unsigned int bitrate;       /**< For uncompressed, can also be used to determine bits per sample */
-    unsigned int reserved1;     /**< Reserved for future use */
-    unsigned int reserved2;     /**< Reserved for future use */
-} CUAUDIOFORMAT;
-
-
-/*!
- * \enum CUvideopacketflags
- * Data packet flags
- */
-typedef enum {
-    CUVID_PKT_ENDOFSTREAM   = 0x01,   /**< Set when this is the last packet for this stream  */
-    CUVID_PKT_TIMESTAMP     = 0x02,   /**< Timestamp is valid  */
-    CUVID_PKT_DISCONTINUITY = 0x04    /**< Set when a discontinuity has to be signalled  */
-} CUvideopacketflags;
-
-/*!
- * \struct CUVIDSOURCEDATAPACKET
- * Data Packet
- */
-typedef struct _CUVIDSOURCEDATAPACKET
-{
-    unsigned long flags;            /**< Combination of CUVID_PKT_XXX flags */
-    unsigned long payload_size;     /**< number of bytes in the payload (may be zero if EOS flag is set) */
-    const unsigned char *payload;   /**< Pointer to packet payload data (may be NULL if EOS flag is set) */
-    CUvideotimestamp timestamp;     /**< Presentation timestamp (10MHz clock), only valid if CUVID_PKT_TIMESTAMP flag is set */
-} CUVIDSOURCEDATAPACKET;
-
-// Callback for packet delivery
-typedef int (CUDAAPI *PFNVIDSOURCECALLBACK)(void *, CUVIDSOURCEDATAPACKET *);
-
-/*!
- * \struct CUVIDSOURCEPARAMS
- * Source Params
- */
-typedef struct _CUVIDSOURCEPARAMS
-{
-    unsigned int ulClockRate;                   /**< Timestamp units in Hz (0=default=10000000Hz)  */
-    unsigned int uReserved1[7];                 /**< Reserved for future use - set to zero  */
-    void *pUserData;                            /**< Parameter passed in to the data handlers  */
-    PFNVIDSOURCECALLBACK pfnVideoDataHandler;   /**< Called to deliver audio packets  */
-    PFNVIDSOURCECALLBACK pfnAudioDataHandler;   /**< Called to deliver video packets  */
-    void *pvReserved2[8];                       /**< Reserved for future use - set to NULL */
-} CUVIDSOURCEPARAMS;
-
-/*!
- * \enum CUvideosourceformat_flags
- * CUvideosourceformat_flags
- */
-typedef enum {
-    CUVID_FMT_EXTFORMATINFO = 0x100             /**< Return extended format structure (CUVIDEOFORMATEX) */
-} CUvideosourceformat_flags;
-
-#if !defined(__APPLE__)
-/**
- * \fn CUresult CUDAAPI cuvidCreateVideoSource(CUvideosource *pObj, const char *pszFileName, CUVIDSOURCEPARAMS *pParams)
- * Create Video Source
- */
-CUresult CUDAAPI cuvidCreateVideoSource(CUvideosource *pObj, const char *pszFileName, CUVIDSOURCEPARAMS *pParams);
-
-/**
- * \fn CUresult CUDAAPI cuvidCreateVideoSourceW(CUvideosource *pObj, const wchar_t *pwszFileName, CUVIDSOURCEPARAMS *pParams)
- * Create Video Source
- */
-CUresult CUDAAPI cuvidCreateVideoSourceW(CUvideosource *pObj, const wchar_t *pwszFileName, CUVIDSOURCEPARAMS *pParams);
-
-/**
- * \fn CUresult CUDAAPI cuvidDestroyVideoSource(CUvideosource obj)
- * Destroy Video Source
- */
-CUresult CUDAAPI cuvidDestroyVideoSource(CUvideosource obj);
-
-/**
- * \fn CUresult CUDAAPI cuvidSetVideoSourceState(CUvideosource obj, cudaVideoState state)
- * Set Video Source state
- */
-CUresult CUDAAPI cuvidSetVideoSourceState(CUvideosource obj, cudaVideoState state);
-
-/**
- * \fn cudaVideoState CUDAAPI cuvidGetVideoSourceState(CUvideosource obj)
- * Get Video Source state
- */
-cudaVideoState CUDAAPI cuvidGetVideoSourceState(CUvideosource obj);
-
-/**
- * \fn CUresult CUDAAPI cuvidGetSourceVideoFormat(CUvideosource obj, CUVIDEOFORMAT *pvidfmt, unsigned int flags)
- * Get Video Source Format
- */
-CUresult CUDAAPI cuvidGetSourceVideoFormat(CUvideosource obj, CUVIDEOFORMAT *pvidfmt, unsigned int flags);
-
-/**
- * \fn CUresult CUDAAPI cuvidGetSourceAudioFormat(CUvideosource obj, CUAUDIOFORMAT *paudfmt, unsigned int flags)
- * Set Video Source state
- */
-CUresult CUDAAPI cuvidGetSourceAudioFormat(CUvideosource obj, CUAUDIOFORMAT *paudfmt, unsigned int flags);
-
-#endif
-
-/**
- * \struct CUVIDPARSERDISPINFO
- */
-typedef struct _CUVIDPARSERDISPINFO
-{
-    int picture_index;         /**<                 */
-    int progressive_frame;     /**<                 */
-    int top_field_first;       /**<                 */
-    int repeat_first_field;    /**< Number of additional fields (1=ivtc, 2=frame doubling, 4=frame tripling, -1=unpaired field)  */
-    CUvideotimestamp timestamp; /**<     */
-} CUVIDPARSERDISPINFO;
-
-//
-// Parser callbacks
-// The parser will call these synchronously from within cuvidParseVideoData(), whenever a picture is ready to
-// be decoded and/or displayed.
-//
-typedef int (CUDAAPI *PFNVIDSEQUENCECALLBACK)(void *, CUVIDEOFORMAT *);
-typedef int (CUDAAPI *PFNVIDDECODECALLBACK)(void *, CUVIDPICPARAMS *);
-typedef int (CUDAAPI *PFNVIDDISPLAYCALLBACK)(void *, CUVIDPARSERDISPINFO *);
-
-/**
- * \struct CUVIDPARSERPARAMS
- */
-typedef struct _CUVIDPARSERPARAMS
-{
-    cudaVideoCodec CodecType;               /**< cudaVideoCodec_XXX  */
-    unsigned int ulMaxNumDecodeSurfaces;    /**< Max # of decode surfaces (parser will cycle through these) */
-    unsigned int ulClockRate;               /**< Timestamp units in Hz (0=default=10000000Hz) */
-    unsigned int ulErrorThreshold;          /**< % Error threshold (0-100) for calling pfnDecodePicture (100=always call pfnDecodePicture even if picture bitstream is fully corrupted) */
-    unsigned int ulMaxDisplayDelay;         /**< Max display queue delay (improves pipelining of decode with display) - 0=no delay (recommended values: 2..4) */
-    unsigned int uReserved1[5];             /**< Reserved for future use - set to 0 */
-    void *pUserData;                        /**< User data for callbacks */
-    PFNVIDSEQUENCECALLBACK pfnSequenceCallback; /**< Called before decoding frames and/or whenever there is a format change */
-    PFNVIDDECODECALLBACK pfnDecodePicture;      /**< Called when a picture is ready to be decoded (decode order) */
-    PFNVIDDISPLAYCALLBACK pfnDisplayPicture;    /**< Called whenever a picture is ready to be displayed (display order)  */
-    void *pvReserved2[7];                       /**< Reserved for future use - set to NULL */
-    CUVIDEOFORMATEX *pExtVideoInfo;             /**< [Optional] sequence header data from system layer */
-} CUVIDPARSERPARAMS;
-
-/**
- * \fn CUresult CUDAAPI cuvidCreateVideoParser(CUvideoparser *pObj, CUVIDPARSERPARAMS *pParams)
- */
-CUresult CUDAAPI cuvidCreateVideoParser(CUvideoparser *pObj, CUVIDPARSERPARAMS *pParams);
-
-/**
- * \fn CUresult CUDAAPI cuvidParseVideoData(CUvideoparser obj, CUVIDSOURCEDATAPACKET *pPacket)
- */
-CUresult CUDAAPI cuvidParseVideoData(CUvideoparser obj, CUVIDSOURCEDATAPACKET *pPacket);
-
-/**
- * \fn CUresult CUDAAPI cuvidDestroyVideoParser(CUvideoparser obj)
- */
-CUresult CUDAAPI cuvidDestroyVideoParser(CUvideoparser obj);
-
-/** @} */  /* END VIDEO_PARSER */
-////////////////////////////////////////////////////////////////////////////////////////////////
-
-#if defined(__cplusplus)
-}
-#endif /* __cplusplus */
-
-#endif // __NVCUVID_H__
-
-
diff --git a/libavcodec/cuvid.c b/libavcodec/cuvid.c
index eafce0a..c3e831a 100644
--- a/libavcodec/cuvid.c
+++ b/libavcodec/cuvid.c
@@ -19,10 +19,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include "compat/cuda/dynlink_loader.h"
+
 #include "libavutil/buffer.h"
 #include "libavutil/mathematics.h"
 #include "libavutil/hwcontext.h"
-#include "libavutil/hwcontext_cuda.h"
+#include "libavutil/hwcontext_cuda_internal.h"
 #include "libavutil/fifo.h"
 #include "libavutil/log.h"
 #include "libavutil/opt.h"
@@ -30,8 +32,6 @@
 #include "avcodec.h"
 #include "internal.h"
 
-#include "compat/cuda/nvcuvid.h"
-
 #define MAX_FRAME_COUNT 25
 
 typedef struct CuvidContext
@@ -61,6 +61,9 @@ typedef struct CuvidContext
 
     CUVIDPARSERPARAMS cuparseinfo;
     CUVIDEOFORMATEX cuparse_ext;
+
+    CudaFunctions *cudl;
+    CuvidFunctions *cvdl;
 } CuvidContext;
 
 typedef struct CuvidParsedFrame
@@ -72,6 +75,7 @@ typedef struct CuvidParsedFrame
 
 static int check_cu(AVCodecContext *avctx, CUresult err, const char *func)
 {
+    CuvidContext *ctx = avctx->priv_data;
     const char *err_name;
     const char *err_string;
 
@@ -80,8 +84,8 @@ static int check_cu(AVCodecContext *avctx, CUresult err, const char *func)
     if (err == CUDA_SUCCESS)
         return 0;
 
-    cuGetErrorName(err, &err_name);
-    cuGetErrorString(err, &err_string);
+    ctx->cudl->cuGetErrorName(err, &err_name);
+    ctx->cudl->cuGetErrorString(err, &err_string);
 
     av_log(avctx, AV_LOG_ERROR, "%s failed", func);
     if (err_name && err_string)
@@ -142,7 +146,7 @@ static int CUDAAPI cuvid_handle_video_sequence(void *opaque, CUVIDEOFORMAT* form
 
     if (ctx->cudecoder) {
         av_log(avctx, AV_LOG_TRACE, "Re-initializing decoder\n");
-        ctx->internal_error = CHECK_CU(cuvidDestroyDecoder(ctx->cudecoder));
+        ctx->internal_error = CHECK_CU(ctx->cvdl->cuvidDestroyDecoder(ctx->cudecoder));
         if (ctx->internal_error < 0)
             return 0;
         ctx->cudecoder = NULL;
@@ -199,7 +203,7 @@ static int CUDAAPI cuvid_handle_video_sequence(void *opaque, CUVIDEOFORMAT* form
     if (ctx->deint_mode != cudaVideoDeinterlaceMode_Weave)
         avctx->framerate = av_mul_q(avctx->framerate, (AVRational){2, 1});
 
-    ctx->internal_error = CHECK_CU(cuvidCreateDecoder(&ctx->cudecoder, &cuinfo));
+    ctx->internal_error = CHECK_CU(ctx->cvdl->cuvidCreateDecoder(&ctx->cudecoder, &cuinfo));
     if (ctx->internal_error < 0)
         return 0;
 
@@ -225,7 +229,7 @@ static int CUDAAPI cuvid_handle_picture_decode(void *opaque, CUVIDPICPARAMS* pic
 
     av_log(avctx, AV_LOG_TRACE, "pfnDecodePicture\n");
 
-    ctx->internal_error = CHECK_CU(cuvidDecodePicture(ctx->cudecoder, picparams));
+    ctx->internal_error = CHECK_CU(ctx->cvdl->cuvidDecodePicture(ctx->cudecoder, picparams));
     if (ctx->internal_error < 0)
         return 0;
 
@@ -291,7 +295,7 @@ static int cuvid_decode_packet(AVCodecContext *avctx, const AVPacket *avpkt)
         avpkt = &filtered_packet;
     }
 
-    ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx));
+    ret = CHECK_CU(ctx->cudl->cuCtxPushCurrent(cuda_ctx));
     if (ret < 0) {
         av_packet_unref(&filtered_packet);
         return ret;
@@ -315,7 +319,7 @@ static int cuvid_decode_packet(AVCodecContext *avctx, const AVPacket *avpkt)
         ctx->decoder_flushing = 1;
     }
 
-    ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &cupkt));
+    ret = CHECK_CU(ctx->cvdl->cuvidParseVideoData(ctx->cuparser, &cupkt));
 
     av_packet_unref(&filtered_packet);
 
@@ -330,7 +334,7 @@ static int cuvid_decode_packet(AVCodecContext *avctx, const AVPacket *avpkt)
     }
 
 error:
-    eret = CHECK_CU(cuCtxPopCurrent(&dummy));
+    eret = CHECK_CU(ctx->cudl->cuCtxPopCurrent(&dummy));
 
     if (eret < 0)
         return eret;
@@ -359,7 +363,7 @@ static int cuvid_output_frame(AVCodecContext *avctx, AVFrame *frame)
             return ret;
     }
 
-    ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx));
+    ret = CHECK_CU(ctx->cudl->cuCtxPushCurrent(cuda_ctx));
     if (ret < 0)
         return ret;
 
@@ -377,7 +381,7 @@ static int cuvid_output_frame(AVCodecContext *avctx, AVFrame *frame)
         params.second_field = parsed_frame.second_field;
         params.top_field_first = parsed_frame.dispinfo.top_field_first;
 
-        ret = CHECK_CU(cuvidMapVideoFrame(ctx->cudecoder, parsed_frame.dispinfo.picture_index, &mapped_frame, &pitch, &params));
+        ret = CHECK_CU(ctx->cvdl->cuvidMapVideoFrame(ctx->cudecoder, parsed_frame.dispinfo.picture_index, &mapped_frame, &pitch, &params));
         if (ret < 0)
             goto error;
 
@@ -407,7 +411,7 @@ static int cuvid_output_frame(AVCodecContext *avctx, AVFrame *frame)
                     .Height        = avctx->height >> (i ? 1 : 0),
                 };
 
-                ret = CHECK_CU(cuMemcpy2D(&cpy));
+                ret = CHECK_CU(ctx->cudl->cuMemcpy2D(&cpy));
                 if (ret < 0)
                     goto error;
 
@@ -492,9 +496,9 @@ FF_ENABLE_DEPRECATION_WARNINGS
 
 error:
     if (mapped_frame)
-        eret = CHECK_CU(cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame));
+        eret = CHECK_CU(ctx->cvdl->cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame));
 
-    eret = CHECK_CU(cuCtxPopCurrent(&dummy));
+    eret = CHECK_CU(ctx->cudl->cuCtxPopCurrent(&dummy));
 
     if (eret < 0)
         return eret;
@@ -543,19 +547,24 @@ static av_cold int cuvid_decode_end(AVCodecContext *avctx)
         av_bsf_free(&ctx->bsf);
 
     if (ctx->cuparser)
-        cuvidDestroyVideoParser(ctx->cuparser);
+        ctx->cvdl->cuvidDestroyVideoParser(ctx->cuparser);
 
     if (ctx->cudecoder)
-        cuvidDestroyDecoder(ctx->cudecoder);
+        ctx->cvdl->cuvidDestroyDecoder(ctx->cudecoder);
+
+    ctx->cudl = NULL;
 
     av_buffer_unref(&ctx->hwframe);
     av_buffer_unref(&ctx->hwdevice);
 
+    cuvid_free_functions(&ctx->cvdl);
+
     return 0;
 }
 
 static int cuvid_test_dummy_decoder(AVCodecContext *avctx, CUVIDPARSERPARAMS *cuparseinfo)
 {
+    CuvidContext *ctx = avctx->priv_data;
     CUVIDDECODECREATEINFO cuinfo;
     CUvideodecoder cudec = 0;
     int ret = 0;
@@ -583,11 +592,11 @@ static int cuvid_test_dummy_decoder(AVCodecContext *avctx, CUVIDPARSERPARAMS *cu
 
     cuinfo.DeinterlaceMode = cudaVideoDeinterlaceMode_Weave;
 
-    ret = CHECK_CU(cuvidCreateDecoder(&cudec, &cuinfo));
+    ret = CHECK_CU(ctx->cvdl->cuvidCreateDecoder(&cudec, &cuinfo));
     if (ret < 0)
         return ret;
 
-    ret = CHECK_CU(cuvidDestroyDecoder(cudec));
+    ret = CHECK_CU(ctx->cvdl->cuvidDestroyDecoder(cudec));
     if (ret < 0)
         return ret;
 
@@ -615,6 +624,13 @@ static av_cold int cuvid_decode_init(AVCodecContext *avctx)
         av_log(avctx, AV_LOG_ERROR, "ff_get_format failed: %d\n", ret);
         return ret;
     }
+    avctx->pix_fmt = ret;
+
+    ret = cuvid_load_functions(&ctx->cvdl);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Failed loading nvcuvid.\n");
+        goto error;
+    }
 
     ctx->frame_queue = av_fifo_alloc(MAX_FRAME_COUNT * sizeof(CuvidParsedFrame));
     if (!ctx->frame_queue) {
@@ -622,8 +638,6 @@ static av_cold int cuvid_decode_init(AVCodecContext *avctx)
         goto error;
     }
 
-    avctx->pix_fmt = ret;
-
     if (avctx->hw_frames_ctx) {
         ctx->hwframe = av_buffer_ref(avctx->hw_frames_ctx);
         if (!ctx->hwframe) {
@@ -655,7 +669,9 @@ static av_cold int cuvid_decode_init(AVCodecContext *avctx)
 
     device_ctx = hwframe_ctx->device_ctx;
     device_hwctx = device_ctx->hwctx;
+
     cuda_ctx = device_hwctx->cuda_ctx;
+    ctx->cudl = device_hwctx->internal->cuda_dl;
 
     memset(&ctx->cuparseinfo, 0, sizeof(ctx->cuparseinfo));
     memset(&ctx->cuparse_ext, 0, sizeof(ctx->cuparse_ext));
@@ -750,7 +766,7 @@ static av_cold int cuvid_decode_init(AVCodecContext *avctx)
     ctx->cuparseinfo.pfnDecodePicture = cuvid_handle_picture_decode;
     ctx->cuparseinfo.pfnDisplayPicture = cuvid_handle_picture_display;
 
-    ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx));
+    ret = CHECK_CU(ctx->cudl->cuCtxPushCurrent(cuda_ctx));
     if (ret < 0)
         goto error;
 
@@ -758,7 +774,7 @@ static av_cold int cuvid_decode_init(AVCodecContext *avctx)
     if (ret < 0)
         goto error;
 
-    ret = CHECK_CU(cuvidCreateVideoParser(&ctx->cuparser, &ctx->cuparseinfo));
+    ret = CHECK_CU(ctx->cvdl->cuvidCreateVideoParser(&ctx->cuparser, &ctx->cuparseinfo));
     if (ret < 0)
         goto error;
 
@@ -766,12 +782,12 @@ static av_cold int cuvid_decode_init(AVCodecContext *avctx)
     seq_pkt.payload_size = ctx->cuparse_ext.format.seqhdr_data_length;
 
     if (seq_pkt.payload && seq_pkt.payload_size) {
-        ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &seq_pkt));
+        ret = CHECK_CU(ctx->cvdl->cuvidParseVideoData(ctx->cuparser, &seq_pkt));
         if (ret < 0)
             goto error;
     }
 
-    ret = CHECK_CU(cuCtxPopCurrent(&dummy));
+    ret = CHECK_CU(ctx->cudl->cuCtxPopCurrent(&dummy));
     if (ret < 0)
         goto error;
 
@@ -796,7 +812,7 @@ static void cuvid_flush(AVCodecContext *avctx)
     CUVIDSOURCEDATAPACKET seq_pkt = { 0 };
     int ret;
 
-    ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx));
+    ret = CHECK_CU(ctx->cudl->cuCtxPushCurrent(cuda_ctx));
     if (ret < 0)
         goto error;
 
@@ -809,16 +825,16 @@ static void cuvid_flush(AVCodecContext *avctx)
     }
 
     if (ctx->cudecoder) {
-        cuvidDestroyDecoder(ctx->cudecoder);
+        ctx->cvdl->cuvidDestroyDecoder(ctx->cudecoder);
         ctx->cudecoder = NULL;
     }
 
     if (ctx->cuparser) {
-        cuvidDestroyVideoParser(ctx->cuparser);
+        ctx->cvdl->cuvidDestroyVideoParser(ctx->cuparser);
         ctx->cuparser = NULL;
     }
 
-    ret = CHECK_CU(cuvidCreateVideoParser(&ctx->cuparser, &ctx->cuparseinfo));
+    ret = CHECK_CU(ctx->cvdl->cuvidCreateVideoParser(&ctx->cuparser, &ctx->cuparseinfo));
     if (ret < 0)
         goto error;
 
@@ -826,12 +842,12 @@ static void cuvid_flush(AVCodecContext *avctx)
     seq_pkt.payload_size = ctx->cuparse_ext.format.seqhdr_data_length;
 
     if (seq_pkt.payload && seq_pkt.payload_size) {
-        ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &seq_pkt));
+        ret = CHECK_CU(ctx->cvdl->cuvidParseVideoData(ctx->cuparser, &seq_pkt));
         if (ret < 0)
             goto error;
     }
 
-    ret = CHECK_CU(cuCtxPopCurrent(&dummy));
+    ret = CHECK_CU(ctx->cudl->cuCtxPopCurrent(&dummy));
     if (ret < 0)
         goto error;
 
-- 
2.10.1


From 0ee0b6cf51877bb70758ace5ed28a4987256e1ee Mon Sep 17 00:00:00 2001
From: Timo Rothenpieler <timo@rothenpieler.org>
Date: Mon, 10 Oct 2016 12:54:42 +0200
Subject: [PATCH 4/8] avfilter/vf_scale_npp: use dynamically loaded CUDA

---
 libavfilter/vf_scale_npp.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/libavfilter/vf_scale_npp.c b/libavfilter/vf_scale_npp.c
index 8eafdc8..78f541e 100644
--- a/libavfilter/vf_scale_npp.c
+++ b/libavfilter/vf_scale_npp.c
@@ -29,7 +29,7 @@
 #include "libavutil/common.h"
 #include "libavutil/eval.h"
 #include "libavutil/hwcontext.h"
-#include "libavutil/hwcontext_cuda.h"
+#include "libavutil/hwcontext_cuda_internal.h"
 #include "libavutil/internal.h"
 #include "libavutil/mathematics.h"
 #include "libavutil/opt.h"
@@ -591,7 +591,7 @@ static int nppscale_filter_frame(AVFilterLink *link, AVFrame *in)
               (int64_t)in->sample_aspect_ratio.den * outlink->w * link->h,
               INT_MAX);
 
-    err = cuCtxPushCurrent(device_hwctx->cuda_ctx);
+    err = device_hwctx->internal->cuda_dl->cuCtxPushCurrent(device_hwctx->cuda_ctx);
     if (err != CUDA_SUCCESS) {
         ret = AVERROR_UNKNOWN;
         goto fail;
@@ -599,7 +599,7 @@ static int nppscale_filter_frame(AVFilterLink *link, AVFrame *in)
 
     ret = nppscale_scale(ctx, out, in);
 
-    cuCtxPopCurrent(&dummy);
+    device_hwctx->internal->cuda_dl->cuCtxPopCurrent(&dummy);
     if (ret < 0)
         goto fail;
 
-- 
2.10.1


From 2687833ef83040ad5b883fcab5fcf8336f8c15ad Mon Sep 17 00:00:00 2001
From: Timo Rothenpieler <timo@rothenpieler.org>
Date: Mon, 10 Oct 2016 12:55:59 +0200
Subject: [PATCH 5/8] avcodec/nvenc: use dynamically loaded CUDA

---
 configure          |   1 +
 libavcodec/nvenc.c | 125 ++++++++++-------------------------------------------
 libavcodec/nvenc.h |  46 ++------------------
 3 files changed, 26 insertions(+), 146 deletions(-)

diff --git a/configure b/configure
index 06cb5d2..9fe054a 100755
--- a/configure
+++ b/configure
@@ -2694,6 +2694,7 @@ vaapi_encode_deps="vaapi"
 hwupload_cuda_filter_deps="cuda"
 scale_npp_filter_deps="cuda libnpp"
 
+nvenc_deps="cuda"
 nvenc_deps_any="dlopen LoadLibrary"
 nvenc_encoder_deps="nvenc"
 h264_cuvid_decoder_deps="cuda cuvid"
diff --git a/libavcodec/nvenc.c b/libavcodec/nvenc.c
index a3a2ef5..d71a445 100644
--- a/libavcodec/nvenc.c
+++ b/libavcodec/nvenc.c
@@ -21,56 +21,20 @@
 
 #include "config.h"
 
-#if defined(_WIN32) || defined(__CYGWIN__)
-# define CUDA_LIBNAME "nvcuda.dll"
-# if ARCH_X86_64
-#  define NVENC_LIBNAME "nvEncodeAPI64.dll"
-# else
-#  define NVENC_LIBNAME "nvEncodeAPI.dll"
-# endif
-#else
-# define CUDA_LIBNAME "libcuda.so.1"
-# define NVENC_LIBNAME "libnvidia-encode.so.1"
-#endif
-
-#if defined(_WIN32)
-#include "compat/w32dlfcn.h"
-#else
-#include <dlfcn.h>
-#endif
+#include "nvenc.h"
 
+#include "libavutil/hwcontext_cuda.h"
 #include "libavutil/hwcontext.h"
 #include "libavutil/imgutils.h"
 #include "libavutil/avassert.h"
 #include "libavutil/mem.h"
 #include "internal.h"
-#include "nvenc.h"
 
 #define NVENC_CAP 0x30
 #define IS_CBR(rc) (rc == NV_ENC_PARAMS_RC_CBR ||               \
                     rc == NV_ENC_PARAMS_RC_2_PASS_QUALITY ||    \
                     rc == NV_ENC_PARAMS_RC_2_PASS_FRAMESIZE_CAP)
 
-#define LOAD_LIBRARY(l, path)                   \
-    do {                                        \
-        if (!((l) = dlopen(path, RTLD_LAZY))) { \
-            av_log(avctx, AV_LOG_ERROR,         \
-                   "Cannot load %s\n",          \
-                   path);                       \
-            return AVERROR_UNKNOWN;             \
-        }                                       \
-    } while (0)
-
-#define LOAD_SYMBOL(fun, lib, symbol)        \
-    do {                                     \
-        if (!((fun) = dlsym(lib, symbol))) { \
-            av_log(avctx, AV_LOG_ERROR,      \
-                   "Cannot load %s\n",       \
-                   symbol);                  \
-            return AVERROR_UNKNOWN;          \
-        }                                    \
-    } while (0)
-
 const enum AVPixelFormat ff_nvenc_pix_fmts[] = {
     AV_PIX_FMT_YUV420P,
     AV_PIX_FMT_NV12,
@@ -79,9 +43,7 @@ const enum AVPixelFormat ff_nvenc_pix_fmts[] = {
     AV_PIX_FMT_YUV444P16,
     AV_PIX_FMT_0RGB32,
     AV_PIX_FMT_0BGR32,
-#if CONFIG_CUDA
     AV_PIX_FMT_CUDA,
-#endif
     AV_PIX_FMT_NONE
 };
 
@@ -153,42 +115,19 @@ static av_cold int nvenc_load_libraries(AVCodecContext *avctx)
 {
     NvencContext *ctx = avctx->priv_data;
     NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;
-    PNVENCODEAPIGETMAXSUPPORTEDVERSION nvenc_get_max_ver;
-    PNVENCODEAPICREATEINSTANCE nvenc_create_instance;
     NVENCSTATUS err;
     uint32_t nvenc_max_ver;
+    int ret;
 
-#if CONFIG_CUDA
-    dl_fn->cu_init                      = cuInit;
-    dl_fn->cu_device_get_count          = cuDeviceGetCount;
-    dl_fn->cu_device_get                = cuDeviceGet;
-    dl_fn->cu_device_get_name           = cuDeviceGetName;
-    dl_fn->cu_device_compute_capability = cuDeviceComputeCapability;
-    dl_fn->cu_ctx_create                = cuCtxCreate_v2;
-    dl_fn->cu_ctx_pop_current           = cuCtxPopCurrent_v2;
-    dl_fn->cu_ctx_destroy               = cuCtxDestroy_v2;
-#else
-    LOAD_LIBRARY(dl_fn->cuda, CUDA_LIBNAME);
-
-    LOAD_SYMBOL(dl_fn->cu_init, dl_fn->cuda, "cuInit");
-    LOAD_SYMBOL(dl_fn->cu_device_get_count, dl_fn->cuda, "cuDeviceGetCount");
-    LOAD_SYMBOL(dl_fn->cu_device_get, dl_fn->cuda, "cuDeviceGet");
-    LOAD_SYMBOL(dl_fn->cu_device_get_name, dl_fn->cuda, "cuDeviceGetName");
-    LOAD_SYMBOL(dl_fn->cu_device_compute_capability, dl_fn->cuda,
-                "cuDeviceComputeCapability");
-    LOAD_SYMBOL(dl_fn->cu_ctx_create, dl_fn->cuda, "cuCtxCreate_v2");
-    LOAD_SYMBOL(dl_fn->cu_ctx_pop_current, dl_fn->cuda, "cuCtxPopCurrent_v2");
-    LOAD_SYMBOL(dl_fn->cu_ctx_destroy, dl_fn->cuda, "cuCtxDestroy_v2");
-#endif
-
-    LOAD_LIBRARY(dl_fn->nvenc, NVENC_LIBNAME);
+    ret = cuda_load_functions(&dl_fn->cuda_dl);
+    if (ret < 0)
+        return ret;
 
-    LOAD_SYMBOL(nvenc_get_max_ver, dl_fn->nvenc,
-                "NvEncodeAPIGetMaxSupportedVersion");
-    LOAD_SYMBOL(nvenc_create_instance, dl_fn->nvenc,
-                "NvEncodeAPICreateInstance");
+    ret = nvenc_load_functions(&dl_fn->nvenc_dl);
+    if (ret < 0)
+        return ret;
 
-    err = nvenc_get_max_ver(&nvenc_max_ver);
+    err = dl_fn->nvenc_dl->NvEncodeAPIGetMaxSupportedVersion(&nvenc_max_ver);
     if (err != NV_ENC_SUCCESS)
         return nvenc_print_error(avctx, err, "Failed to query nvenc max version");
 
@@ -204,7 +143,7 @@ static av_cold int nvenc_load_libraries(AVCodecContext *avctx)
 
     dl_fn->nvenc_funcs.version = NV_ENCODE_API_FUNCTION_LIST_VER;
 
-    err = nvenc_create_instance(&dl_fn->nvenc_funcs);
+    err = dl_fn->nvenc_dl->NvEncodeAPICreateInstance(&dl_fn->nvenc_funcs);
     if (err != NV_ENC_SUCCESS)
         return nvenc_print_error(avctx, err, "Failed to create nvenc instance");
 
@@ -376,7 +315,7 @@ static av_cold int nvenc_check_device(AVCodecContext *avctx, int idx)
     if (ctx->device == LIST_DEVICES)
         loglevel = AV_LOG_INFO;
 
-    cu_res = dl_fn->cu_device_get(&cu_device, idx);
+    cu_res = dl_fn->cuda_dl->cuDeviceGet(&cu_device, idx);
     if (cu_res != CUDA_SUCCESS) {
         av_log(avctx, AV_LOG_ERROR,
                "Cannot access the CUDA device %d\n",
@@ -384,11 +323,11 @@ static av_cold int nvenc_check_device(AVCodecContext *avctx, int idx)
         return -1;
     }
 
-    cu_res = dl_fn->cu_device_get_name(name, sizeof(name), cu_device);
+    cu_res = dl_fn->cuda_dl->cuDeviceGetName(name, sizeof(name), cu_device);
     if (cu_res != CUDA_SUCCESS)
         return -1;
 
-    cu_res = dl_fn->cu_device_compute_capability(&major, &minor, cu_device);
+    cu_res = dl_fn->cuda_dl->cuDeviceComputeCapability(&major, &minor, cu_device);
     if (cu_res != CUDA_SUCCESS)
         return -1;
 
@@ -398,7 +337,7 @@ static av_cold int nvenc_check_device(AVCodecContext *avctx, int idx)
         goto fail;
     }
 
-    cu_res = dl_fn->cu_ctx_create(&ctx->cu_context_internal, 0, cu_device);
+    cu_res = dl_fn->cuda_dl->cuCtxCreate(&ctx->cu_context_internal, 0, cu_device);
     if (cu_res != CUDA_SUCCESS) {
         av_log(avctx, AV_LOG_FATAL, "Failed creating CUDA context for NVENC: 0x%x\n", (int)cu_res);
         goto fail;
@@ -406,7 +345,7 @@ static av_cold int nvenc_check_device(AVCodecContext *avctx, int idx)
 
     ctx->cu_context = ctx->cu_context_internal;
 
-    cu_res = dl_fn->cu_ctx_pop_current(&dummy);
+    cu_res = dl_fn->cuda_dl->cuCtxPopCurrent(&dummy);
     if (cu_res != CUDA_SUCCESS) {
         av_log(avctx, AV_LOG_FATAL, "Failed popping CUDA context: 0x%x\n", (int)cu_res);
         goto fail2;
@@ -430,7 +369,7 @@ fail3:
     ctx->nvencoder = NULL;
 
 fail2:
-    dl_fn->cu_ctx_destroy(ctx->cu_context_internal);
+    dl_fn->cuda_dl->cuCtxDestroy(ctx->cu_context_internal);
     ctx->cu_context_internal = NULL;
 
 fail:
@@ -454,7 +393,6 @@ static av_cold int nvenc_setup_device(AVCodecContext *avctx)
     }
 
     if (avctx->pix_fmt == AV_PIX_FMT_CUDA) {
-#if CONFIG_CUDA
         AVHWFramesContext   *frames_ctx;
         AVCUDADeviceContext *device_hwctx;
         int ret;
@@ -476,19 +414,16 @@ static av_cold int nvenc_setup_device(AVCodecContext *avctx)
             av_log(avctx, AV_LOG_FATAL, "Provided device doesn't support required NVENC features\n");
             return ret;
         }
-#else
-        return AVERROR_BUG;
-#endif
     } else {
         int i, nb_devices = 0;
 
-        if ((dl_fn->cu_init(0)) != CUDA_SUCCESS) {
+        if ((dl_fn->cuda_dl->cuInit(0)) != CUDA_SUCCESS) {
             av_log(avctx, AV_LOG_ERROR,
                    "Cannot init CUDA\n");
             return AVERROR_UNKNOWN;
         }
 
-        if ((dl_fn->cu_device_get_count(&nb_devices)) != CUDA_SUCCESS) {
+        if ((dl_fn->cuda_dl->cuDeviceGetCount(&nb_devices)) != CUDA_SUCCESS) {
             av_log(avctx, AV_LOG_ERROR,
                    "Cannot enumerate the CUDA devices\n");
             return AVERROR_UNKNOWN;
@@ -1265,30 +1200,14 @@ av_cold int ff_nvenc_encode_close(AVCodecContext *avctx)
     ctx->nvencoder = NULL;
 
     if (ctx->cu_context_internal)
-        dl_fn->cu_ctx_destroy(ctx->cu_context_internal);
+        dl_fn->cuda_dl->cuCtxDestroy(ctx->cu_context_internal);
     ctx->cu_context = ctx->cu_context_internal = NULL;
 
-    if (dl_fn->nvenc)
-        dlclose(dl_fn->nvenc);
-    dl_fn->nvenc = NULL;
+    nvenc_free_functions(&dl_fn->nvenc_dl);
+    cuda_free_functions(&dl_fn->cuda_dl);
 
     dl_fn->nvenc_device_count = 0;
 
-#if !CONFIG_CUDA
-    if (dl_fn->cuda)
-        dlclose(dl_fn->cuda);
-    dl_fn->cuda = NULL;
-#endif
-
-    dl_fn->cu_init = NULL;
-    dl_fn->cu_device_get_count = NULL;
-    dl_fn->cu_device_get = NULL;
-    dl_fn->cu_device_get_name = NULL;
-    dl_fn->cu_device_compute_capability = NULL;
-    dl_fn->cu_ctx_create = NULL;
-    dl_fn->cu_ctx_pop_current = NULL;
-    dl_fn->cu_ctx_destroy = NULL;
-
     av_log(avctx, AV_LOG_VERBOSE, "Nvenc unloaded\n");
 
     return 0;
diff --git a/libavcodec/nvenc.h b/libavcodec/nvenc.h
index bad659a..5bc0cba 100644
--- a/libavcodec/nvenc.h
+++ b/libavcodec/nvenc.h
@@ -23,29 +23,12 @@
 
 #include "config.h"
 
+#include "compat/cuda/dynlink_loader.h"
 #include "libavutil/fifo.h"
 #include "libavutil/opt.h"
 
 #include "avcodec.h"
 
-#if CONFIG_CUDA
-#include "libavutil/hwcontext_cuda.h"
-#else
-
-#if defined(_WIN32)
-#define CUDAAPI __stdcall
-#else
-#define CUDAAPI
-#endif
-
-typedef enum cudaError_enum {
-    CUDA_SUCCESS = 0
-} CUresult;
-typedef int CUdevice;
-typedef void* CUcontext;
-typedef void* CUdeviceptr;
-#endif
-
 #define MAX_REGISTERED_FRAMES 64
 
 typedef struct NvencSurface
@@ -64,33 +47,10 @@ typedef struct NvencSurface
     int lockCount;
 } NvencSurface;
 
-typedef CUresult(CUDAAPI *PCUINIT)(unsigned int Flags);
-typedef CUresult(CUDAAPI *PCUDEVICEGETCOUNT)(int *count);
-typedef CUresult(CUDAAPI *PCUDEVICEGET)(CUdevice *device, int ordinal);
-typedef CUresult(CUDAAPI *PCUDEVICEGETNAME)(char *name, int len, CUdevice dev);
-typedef CUresult(CUDAAPI *PCUDEVICECOMPUTECAPABILITY)(int *major, int *minor, CUdevice dev);
-typedef CUresult(CUDAAPI *PCUCTXCREATE)(CUcontext *pctx, unsigned int flags, CUdevice dev);
-typedef CUresult(CUDAAPI *PCUCTXPOPCURRENT)(CUcontext *pctx);
-typedef CUresult(CUDAAPI *PCUCTXDESTROY)(CUcontext ctx);
-
-typedef NVENCSTATUS (NVENCAPI *PNVENCODEAPIGETMAXSUPPORTEDVERSION)(uint32_t* version);
-typedef NVENCSTATUS (NVENCAPI *PNVENCODEAPICREATEINSTANCE)(NV_ENCODE_API_FUNCTION_LIST *functionList);
-
 typedef struct NvencDynLoadFunctions
 {
-#if !CONFIG_CUDA
-    void *cuda;
-#endif
-    void *nvenc;
-
-    PCUINIT cu_init;
-    PCUDEVICEGETCOUNT cu_device_get_count;
-    PCUDEVICEGET cu_device_get;
-    PCUDEVICEGETNAME cu_device_get_name;
-    PCUDEVICECOMPUTECAPABILITY cu_device_compute_capability;
-    PCUCTXCREATE cu_ctx_create;
-    PCUCTXPOPCURRENT cu_ctx_pop_current;
-    PCUCTXDESTROY cu_ctx_destroy;
+    CudaFunctions *cuda_dl;
+    NvencFunctions *nvenc_dl;
 
     NV_ENCODE_API_FUNCTION_LIST nvenc_funcs;
     int nvenc_device_count;
-- 
2.10.1


From c5a54aba8f588af345243344972ba186bb7a621c Mon Sep 17 00:00:00 2001
From: Timo Rothenpieler <timo@rothenpieler.org>
Date: Mon, 10 Oct 2016 12:56:55 +0200
Subject: [PATCH 6/8] avfilter/vf_hwupload_cuda: use new hwdevice allocation
 API

---
 libavfilter/vf_hwupload_cuda.c | 57 ++++--------------------------------------
 1 file changed, 5 insertions(+), 52 deletions(-)

diff --git a/libavfilter/vf_hwupload_cuda.c b/libavfilter/vf_hwupload_cuda.c
index c22221c..dba496f 100644
--- a/libavfilter/vf_hwupload_cuda.c
+++ b/libavfilter/vf_hwupload_cuda.c
@@ -18,7 +18,6 @@
 
 #include "libavutil/buffer.h"
 #include "libavutil/hwcontext.h"
-#include "libavutil/hwcontext_cuda.h"
 #include "libavutil/log.h"
 #include "libavutil/opt.h"
 
@@ -35,60 +34,14 @@ typedef struct CudaUploadContext {
     AVBufferRef *hwframe;
 } CudaUploadContext;
 
-static void cudaupload_ctx_free(AVHWDeviceContext *ctx)
-{
-    AVCUDADeviceContext *hwctx = ctx->hwctx;
-    cuCtxDestroy(hwctx->cuda_ctx);
-}
-
 static av_cold int cudaupload_init(AVFilterContext *ctx)
 {
     CudaUploadContext *s = ctx->priv;
+    char buf[64] = { 0 };
 
-    AVHWDeviceContext   *device_ctx;
-    AVCUDADeviceContext *device_hwctx;
-    CUdevice device;
-    CUcontext cuda_ctx = NULL, dummy;
-    CUresult err;
-    int ret;
-
-    err = cuInit(0);
-    if (err != CUDA_SUCCESS) {
-        av_log(ctx, AV_LOG_ERROR, "Could not initialize the CUDA driver API\n");
-        return AVERROR_UNKNOWN;
-    }
-
-    err = cuDeviceGet(&device, s->device_idx);
-    if (err != CUDA_SUCCESS) {
-        av_log(ctx, AV_LOG_ERROR, "Could not get the device number %d\n", s->device_idx);
-        return AVERROR_UNKNOWN;
-    }
-
-    err = cuCtxCreate(&cuda_ctx, 0, device);
-    if (err != CUDA_SUCCESS) {
-        av_log(ctx, AV_LOG_ERROR, "Error creating a CUDA context\n");
-        return AVERROR_UNKNOWN;
-    }
-
-    cuCtxPopCurrent(&dummy);
-
-    s->hwdevice = av_hwdevice_ctx_alloc(AV_HWDEVICE_TYPE_CUDA);
-    if (!s->hwdevice) {
-        cuCtxDestroy(cuda_ctx);
-        return AVERROR(ENOMEM);
-    }
-
-    device_ctx       = (AVHWDeviceContext*)s->hwdevice->data;
-    device_ctx->free = cudaupload_ctx_free;
+    snprintf(buf, sizeof(buf), "%d", s->device_idx);
 
-    device_hwctx = device_ctx->hwctx;
-    device_hwctx->cuda_ctx = cuda_ctx;
-
-    ret = av_hwdevice_ctx_init(s->hwdevice);
-    if (ret < 0)
-        return ret;
-
-    return 0;
+    return av_hwdevice_ctx_create(&s->hwdevice, AV_HWDEVICE_TYPE_CUDA, buf, NULL, 0);
 }
 
 static av_cold void cudaupload_uninit(AVFilterContext *ctx)
@@ -134,8 +87,8 @@ static int cudaupload_config_output(AVFilterLink *outlink)
     hwframe_ctx            = (AVHWFramesContext*)s->hwframe->data;
     hwframe_ctx->format    = AV_PIX_FMT_CUDA;
     hwframe_ctx->sw_format = inlink->format;
-    hwframe_ctx->width     = FFALIGN(inlink->w, 16);
-    hwframe_ctx->height    = FFALIGN(inlink->h, 16);
+    hwframe_ctx->width     = inlink->w;
+    hwframe_ctx->height    = inlink->h;
 
     ret = av_hwframe_ctx_init(s->hwframe);
     if (ret < 0)
-- 
2.10.1


From 463886b1c3121fa3019cbab661c4e37254bca78b Mon Sep 17 00:00:00 2001
From: Timo Rothenpieler <timo@rothenpieler.org>
Date: Mon, 10 Oct 2016 12:57:29 +0200
Subject: [PATCH 7/8] avfilter/vf_hwupload_cuda: check ff_formats_ref for
 errors

---
 libavfilter/vf_hwupload_cuda.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/libavfilter/vf_hwupload_cuda.c b/libavfilter/vf_hwupload_cuda.c
index dba496f..14688df 100644
--- a/libavfilter/vf_hwupload_cuda.c
+++ b/libavfilter/vf_hwupload_cuda.c
@@ -54,6 +54,8 @@ static av_cold void cudaupload_uninit(AVFilterContext *ctx)
 
 static int cudaupload_query_formats(AVFilterContext *ctx)
 {
+    int ret;
+
     static const enum AVPixelFormat input_pix_fmts[] = {
         AV_PIX_FMT_NV12, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV444P,
         AV_PIX_FMT_NONE,
@@ -64,8 +66,13 @@ static int cudaupload_query_formats(AVFilterContext *ctx)
     AVFilterFormats *in_fmts  = ff_make_format_list(input_pix_fmts);
     AVFilterFormats *out_fmts = ff_make_format_list(output_pix_fmts);
 
-    ff_formats_ref(in_fmts,  &ctx->inputs[0]->out_formats);
-    ff_formats_ref(out_fmts, &ctx->outputs[0]->in_formats);
+    ret = ff_formats_ref(in_fmts, &ctx->inputs[0]->out_formats);
+    if (ret < 0)
+        return ret;
+
+    ret = ff_formats_ref(out_fmts, &ctx->outputs[0]->in_formats);
+    if (ret < 0)
+        return ret;
 
     return 0;
 }
-- 
2.10.1


From 985620a2d9057f29cae48d147f4aebd1d7e619ad Mon Sep 17 00:00:00 2001
From: Timo Rothenpieler <timo@rothenpieler.org>
Date: Mon, 10 Oct 2016 12:58:26 +0200
Subject: [PATCH 8/8] configure: cuda is no longer nonfree, enable and
 autodetect by default

---
 configure | 24 ++++++------------------
 1 file changed, 6 insertions(+), 18 deletions(-)

diff --git a/configure b/configure
index 9fe054a..4a48a52 100755
--- a/configure
+++ b/configure
@@ -298,8 +298,8 @@ External library support:
 
   The following libraries provide various hardware acceleration features:
   --disable-audiotoolbox   disable Apple AudioToolbox code [autodetect]
-  --enable-cuda            enable dynamically linked Nvidia CUDA code [no]
-  --enable-cuvid           enable Nvidia CUVID support [autodetect]
+  --disable-cuda           disable dynamically linked Nvidia CUDA code [autodetect]
+  --disable-cuvid          disable Nvidia CUVID support [autodetect]
   --disable-d3d11va        disable Microsoft Direct3D 11 video acceleration code [autodetect]
   --disable-dxva2          disable Microsoft DirectX 9 video acceleration code [autodetect]
   --enable-libmfx          enable Intel MediaSDK (AKA Quick Sync Video) code via libmfx [no]
@@ -3232,7 +3232,7 @@ enable audiotoolbox
 enable d3d11va dxva2 vaapi vda vdpau videotoolbox_hwaccel xvmc
 enable xlib
 
-enable nvenc vda_framework videotoolbox videotoolbox_encoder
+enable cuda cuvid nvenc vda_framework videotoolbox videotoolbox_encoder
 
 # build settings
 SHFLAGS='-shared -Wl,-soname,$$(@F)'
@@ -5083,8 +5083,6 @@ die_license_disabled gpl libxavs
 die_license_disabled gpl libxvid
 die_license_disabled gpl x11grab
 
-die_license_disabled nonfree cuda
-die_license_disabled nonfree cuvid
 die_license_disabled nonfree libnpp
 enabled gpl && die_license_disabled_gpl nonfree libfdk_aac
 enabled gpl && die_license_disabled_gpl nonfree openssl
@@ -5657,21 +5655,11 @@ for func in $COMPLEX_FUNCS; do
     eval check_complexfunc $func \${${func}_args:-1}
 done
 
-# Enable CUVID by default if CUDA is enabled
-if enabled cuda && ! disabled cuvid; then
-    enable cuvid
-fi
-
 # these are off by default, so fail if requested and not available
 enabled avfoundation_indev && { check_header_objcc AVFoundation/AVFoundation.h || disable avfoundation_indev; }
 enabled avfoundation_indev && { check_lib2 CoreGraphics/CoreGraphics.h CGGetActiveDisplayList -framework CoreGraphics ||
                                 check_lib2 ApplicationServices/ApplicationServices.h CGGetActiveDisplayList -framework ApplicationServices; }
-enabled cuda              && { check_lib cuda.h cuInit -lcuda ||
-                               die "ERROR: CUDA not found"; }
-enabled cuvid             && { add_cflags -I$source_path;
-                               check_lib "compat/cuda/cuviddec.h" cuvidCreateDecoder -lnvcuvid ||
-                               die "ERROR: CUVID not found"; } &&
-                             { enabled cuda ||
+enabled cuvid             && { enabled cuda ||
                                die "ERROR: CUVID requires CUDA"; }
 enabled chromaprint       && require chromaprint chromaprint.h chromaprint_get_version -lchromaprint
 enabled coreimage_filter  && { check_header_objcc QuartzCore/CoreImage.h || disable coreimage_filter; }
@@ -6024,11 +6012,11 @@ if enabled x86; then
         mingw32*|mingw64*|win32|win64|linux|cygwin*)
             ;;
         *)
-            disable nvenc
+            disable cuda cuvid nvenc
             ;;
     esac
 else
-    disable nvenc
+    disable cuda cuvid nvenc
 fi
 
 enabled nvenc &&
-- 
2.10.1

